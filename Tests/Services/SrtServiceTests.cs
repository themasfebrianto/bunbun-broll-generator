using BunbunBroll.Services;
using BunbunBroll.Models;
using Xunit;

namespace BunbunBroll.Tests.Services;

public class SrtServiceTests
{
    private readonly SrtService _service = new();

    [Fact]
    public void ParseSrt_MaintainsPrecision()
    {
        var srt = "1\n00:00:01,123 --> 00:00:04,456\nHello World";
        var results = _service.ParseSrt(srt);

        Assert.Single(results);
        Assert.Equal(1, results[0].StartTime.Seconds);
        Assert.Equal(123, results[0].StartTime.Milliseconds);
        Assert.Equal(4, results[0].EndTime.Seconds);
        Assert.Equal(456, results[0].EndTime.Milliseconds);
    }

    [Fact]
    public void MergeToSegments_SmartSplitAtSentenceEnd()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(5), Text = "This is a sentence." },
            new() { StartTime = TimeSpan.FromSeconds(5), EndTime = TimeSpan.FromSeconds(10), Text = "This is another sentence." },
            new() { StartTime = TimeSpan.FromSeconds(10), EndTime = TimeSpan.FromSeconds(21), Text = "Long segment that might continue." },
            new() { StartTime = TimeSpan.FromSeconds(21), EndTime = TimeSpan.FromSeconds(24), Text = "Ending now." },
            new() { StartTime = TimeSpan.FromSeconds(24), EndTime = TimeSpan.FromSeconds(30), Text = "New topic started." }
        };

        // max 25s. Soft limit 20s (80%).
        var merged = _service.MergeToSegments(entries, 25.0);

        // Expected:
        // 1. [0, 5], [5, 10] combined. Total 10s.
        // 2. Add [10, 21]. Total 21s. Ends with "."? Yes. 21 > 20 (soft limit).
        //    Segment 1: "This is a sentence. This is another sentence. Long segment that might continue."
        // 3. Segment 2: [21s - ...] "Ending now. New topic started."
        
        Assert.Equal(2, merged.Count);
        Assert.DoesNotContain("Ending now.", merged[0].Text);
        Assert.Contains("Ending now.", merged[1].Text);
    }

    [Fact]
    public void MergeToSegments_EnforcesHardLimit()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(10), Text = "Keep going" },
            new() { StartTime = TimeSpan.FromSeconds(10), EndTime = TimeSpan.FromSeconds(20), Text = "No punctuation" },
            new() { StartTime = TimeSpan.FromSeconds(20), EndTime = TimeSpan.FromSeconds(30), Text = "Exceeds 25s limit" }
        };

        var merged = _service.MergeToSegments(entries, 25.0);

        // Expected:
        // 1. [0-10], [10-20] combined. Total 20s. No punctuation.
        // 2. Adding [20-30] makes it 30s (> 25s). 
        //    Segment 1: [0-20] "Keep going No punctuation"
        //    Segment 2: [20-30] "Exceeds 25s limit"
        Assert.Equal(2, merged.Count);
        Assert.Equal("[00:00.000]", merged[0].Timestamp);
        Assert.Equal("Keep going No punctuation", merged[0].Text);
    }

    [Fact]
    public void MergeToSegments_PreservesMilliseconds()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromMilliseconds(1500), EndTime = TimeSpan.FromSeconds(10), Text = "Test" }
        };

        var merged = _service.MergeToSegments(entries, 25.0);

        Assert.Equal("[00:01.500]", merged[0].Timestamp);
    }

    [Fact]
    public void MergeToSegments_SplitsAtGapsWithoutPunctuation()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(10), Text = "No punctuation here" },
            new() { StartTime = TimeSpan.FromSeconds(10), EndTime = TimeSpan.FromSeconds(20), Text = "Still no punctuation but big gap" },
            // Gap of 1.0s between this and next entry
            new() { StartTime = TimeSpan.FromSeconds(21), EndTime = TimeSpan.FromSeconds(25), Text = "This should be new segment" }
        };

        // max 25s. Soft limit 17.5s (70% of 25).
        var merged = _service.MergeToSegments(entries, 25.0);

        // Expected splitting:
        // Segment 1: "No punctuation here Still no punctuation but big gap" (0s to 20s)
        // Segment 2: "This should be new segment" (21s to 25s)
        
        Assert.Equal(2, merged.Count);
        Assert.Contains("big gap", merged[0].Text);
        Assert.DoesNotContain("new segment", merged[0].Text);
    }

    [Fact]
    public void MergeToSegments_AutoGeneratedSrt_SplitsOnWordLimit()
    {
        // Simulate auto-generated SRT: continuous 3s entries, no punctuation, no gaps
        var entries = new List<SrtEntry>();
        for (int i = 0; i < 20; i++)
        {
            entries.Add(new SrtEntry
            {
                StartTime = TimeSpan.FromSeconds(i * 3),
                EndTime = TimeSpan.FromSeconds((i + 1) * 3),
                Text = $"word{i}a word{i}b word{i}c word{i}d word{i}e"  // 5 words per entry
            });
        }

        // With default maxDuration=20s, 80-word limit should force splits
        var merged = _service.MergeToSegments(entries);

        // 20 entries × 5 words = 100 words total, 60s total duration
        // Should produce multiple segments, not a single massive block
        Assert.True(merged.Count >= 2, $"Expected at least 2 segments but got {merged.Count}");
        
        // No segment should have more than 80 words
        foreach (var seg in merged)
        {
            var wordCount = seg.Text.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
            Assert.True(wordCount <= 85, $"Segment has {wordCount} words, exceeding the ~80 word limit");
        }
    }

    [Fact]
    public void RetimeEntriesWithActualDurations_EliminatesCumulativeDrift()
    {
        var entries = new List<SrtEntry>
        {
            new() { OriginalStartTime = TimeSpan.FromSeconds(0), OriginalEndTime = TimeSpan.FromSeconds(2), Text = "Initial" },
            new() { OriginalStartTime = TimeSpan.FromSeconds(2), OriginalEndTime = TimeSpan.FromSeconds(4), Text = "Second" },
            new() { OriginalStartTime = TimeSpan.FromSeconds(4), OriginalEndTime = TimeSpan.FromSeconds(6), Text = "Third" }
        };

        // Theoretical duration of each is 2.0s.
        // But let's say ffmpeg sliced them slightly longer: 2.1s each.
        var segments = new List<VoSegment>
        {
            new() { Index = 1, ActualDurationSeconds = 2.1 },
            new() { Index = 2, ActualDurationSeconds = 2.1 },
            new() { Index = 3, ActualDurationSeconds = 2.1 }
        };

        var pauses = new Dictionary<int, double>
        {
            { 0, 0.5 } // 0.5s pause after the first entry
        };

        _service.RetimeEntriesWithActualDurations(entries, segments, pauses);

        // Entry 1
        Assert.Equal(0, entries[0].StartTime.TotalSeconds);
        Assert.Equal(2.1, entries[0].EndTime.TotalSeconds); // Uses actual segment len

        // Entry 2 starts after Entry 1 + Pause (2.1 + 0.5 = 2.6)
        Assert.Equal(2.6, entries[1].StartTime.TotalSeconds);
        Assert.Equal(4.7, entries[1].EndTime.TotalSeconds); // 2.6 + 2.1

        // Entry 3 starts immediately after Entry 2 (no pause)
        Assert.Equal(4.7, entries[2].StartTime.TotalSeconds);
        Assert.Equal(6.8, entries[2].EndTime.TotalSeconds); // 4.7 + 2.1
    }

    [Fact]
    public void FormatExpandedSrt_WithOverlays_FormatsCorrectly()
    {
        var entries = new List<SrtEntry>
        {
            new() { Text = "First spoken line", StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(2) },
            // Gap of 3 seconds where overlay should appear: 2s to 5s
            new() { Text = "Second spoken line", StartTime = TimeSpan.FromSeconds(5), EndTime = TimeSpan.FromSeconds(7) }
        };

        var overlays = new Dictionary<int, TextOverlayDto>
        {
            { 
                0, // Overlay triggering after the first entry's end time
                new TextOverlayDto { Type = "QuranVerse", Reference = "Al-Baqarah 2:286", Arabic = "لَا يُكَلِّفُ اللَّهُ نَفْسًا إِلَّا وُسْعَهَا" } 
            }
        };

        var result = _service.FormatExpandedSrt(entries, overlays);

        // Assert
        Assert.Contains("First spoken line", result);
        Assert.Contains("Second spoken line", result);

        // Gap entry verification
        Assert.Contains("00:00:02,000 --> 00:00:05,000", result); // Gap time
        Assert.Contains("[OVERLAY:QuranVerse]", result);
        Assert.Contains("[REF] Al-Baqarah 2:286", result);
        Assert.Contains("[ARABIC] لَا يُكَلِّفُ اللَّهُ نَفْسًا إِلَّا وُسْعَهَا", result);
    }
}
