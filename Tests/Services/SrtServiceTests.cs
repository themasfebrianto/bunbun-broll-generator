using BunbunBroll.Services;
using BunbunBroll.Models;
using Xunit;

namespace BunbunBroll.Tests.Services;

public class SrtServiceTests
{
    private readonly SrtService _service = new();

    [Fact]
    public void ParseSrt_MaintainsPrecision()
    {
        var srt = "1\n00:00:01,123 --> 00:00:04,456\nHello World";
        var results = _service.ParseSrt(srt);

        Assert.Single(results);
        Assert.Equal(1, results[0].StartTime.Seconds);
        Assert.Equal(123, results[0].StartTime.Milliseconds);
        Assert.Equal(4, results[0].EndTime.Seconds);
        Assert.Equal(456, results[0].EndTime.Milliseconds);
    }

    [Fact]
    public void MergeToSegments_SmartSplitAtSentenceEnd()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(5), Text = "This is a sentence." },
            new() { StartTime = TimeSpan.FromSeconds(5), EndTime = TimeSpan.FromSeconds(10), Text = "This is another sentence." },
            new() { StartTime = TimeSpan.FromSeconds(10), EndTime = TimeSpan.FromSeconds(21), Text = "Long segment that might continue." },
            new() { StartTime = TimeSpan.FromSeconds(21), EndTime = TimeSpan.FromSeconds(24), Text = "Ending now." },
            new() { StartTime = TimeSpan.FromSeconds(24), EndTime = TimeSpan.FromSeconds(30), Text = "New topic started." }
        };

        // max 25s. Soft limit 20s (80%).
        var merged = _service.MergeToSegments(entries, 25.0);

        // Expected:
        // 1. [0, 5], [5, 10] combined. Total 10s.
        // 2. Add [10, 21]. Total 21s. Ends with "."? Yes. 21 > 20 (soft limit).
        //    Segment 1: "This is a sentence. This is another sentence. Long segment that might continue."
        // 3. Segment 2: [21s - ...] "Ending now. New topic started."
        
        Assert.Equal(2, merged.Count);
        Assert.DoesNotContain("Ending now.", merged[0].Text);
        Assert.Contains("Ending now.", merged[1].Text);
    }

    [Fact]
    public void MergeToSegments_EnforcesHardLimit()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(10), Text = "Keep going" },
            new() { StartTime = TimeSpan.FromSeconds(10), EndTime = TimeSpan.FromSeconds(20), Text = "No punctuation" },
            new() { StartTime = TimeSpan.FromSeconds(20), EndTime = TimeSpan.FromSeconds(30), Text = "Exceeds 25s limit" }
        };

        var merged = _service.MergeToSegments(entries, 25.0);

        // Expected:
        // 1. [0-10], [10-20] combined. Total 20s. No punctuation.
        // 2. Adding [20-30] makes it 30s (> 25s). 
        //    Segment 1: [0-20] "Keep going No punctuation"
        //    Segment 2: [20-30] "Exceeds 25s limit"
        Assert.Equal(2, merged.Count);
        Assert.Equal("[00:00.000]", merged[0].Timestamp);
        Assert.Equal("Keep going No punctuation", merged[0].Text);
    }

    [Fact]
    public void MergeToSegments_PreservesMilliseconds()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromMilliseconds(1500), EndTime = TimeSpan.FromSeconds(10), Text = "Test" }
        };

        var merged = _service.MergeToSegments(entries, 25.0);

        Assert.Equal("[00:01.500]", merged[0].Timestamp);
    }

    [Fact]
    public void MergeToSegments_SplitsAtGapsWithoutPunctuation()
    {
        var entries = new List<SrtEntry>
        {
            new() { StartTime = TimeSpan.FromSeconds(0), EndTime = TimeSpan.FromSeconds(10), Text = "No punctuation here" },
            new() { StartTime = TimeSpan.FromSeconds(10), EndTime = TimeSpan.FromSeconds(20), Text = "Still no punctuation but big gap" },
            // Gap of 1.0s between this and next entry
            new() { StartTime = TimeSpan.FromSeconds(21), EndTime = TimeSpan.FromSeconds(25), Text = "This should be new segment" }
        };

        // max 25s. Soft limit 17.5s (70% of 25).
        var merged = _service.MergeToSegments(entries, 25.0);

        // Expected splitting:
        // Segment 1: "No punctuation here Still no punctuation but big gap" (0s to 20s)
        // Segment 2: "This should be new segment" (21s to 25s)
        
        Assert.Equal(2, merged.Count);
        Assert.Contains("big gap", merged[0].Text);
        Assert.DoesNotContain("new segment", merged[0].Text);
    }

    [Fact]
    public void MergeToSegments_AutoGeneratedSrt_SplitsOnWordLimit()
    {
        // Simulate auto-generated SRT: continuous 3s entries, no punctuation, no gaps
        var entries = new List<SrtEntry>();
        for (int i = 0; i < 20; i++)
        {
            entries.Add(new SrtEntry
            {
                StartTime = TimeSpan.FromSeconds(i * 3),
                EndTime = TimeSpan.FromSeconds((i + 1) * 3),
                Text = $"word{i}a word{i}b word{i}c word{i}d word{i}e"  // 5 words per entry
            });
        }

        // With default maxDuration=20s, 80-word limit should force splits
        var merged = _service.MergeToSegments(entries);

        // 20 entries Ã— 5 words = 100 words total, 60s total duration
        // Should produce multiple segments, not a single massive block
        Assert.True(merged.Count >= 2, $"Expected at least 2 segments but got {merged.Count}");
        
        // No segment should have more than 80 words
        foreach (var seg in merged)
        {
            var wordCount = seg.Text.Split(' ', StringSplitOptions.RemoveEmptyEntries).Length;
            Assert.True(wordCount <= 85, $"Segment has {wordCount} words, exceeding the ~80 word limit");
        }
    }
}
