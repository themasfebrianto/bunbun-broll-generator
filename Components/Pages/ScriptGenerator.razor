@page "/"
@page "/script-generator"
@rendermode InteractiveServer
@using BunbunBroll.Services
@using BunbunBroll.Orchestration
@using BunbunBroll.Models
@using BunbunBroll.Components.Views.ScriptGenerator
@implements IDisposable
@inject IScriptGenerationService ScriptService
@inject IScriptOrchestrator Orchestrator
@inject IConfiguration Configuration
@inject NavigationManager Navigation
@inject ConfigBatchGenerator BatchGenerator
@inject IJSRuntime JS
@inject BackgroundGenerationService BgService
@inject ISrtService SrtService
@inject IPhaseDetectionService PhaseDetectionService
@inject ITimestampSplitterService TimestampSplitterService
@inject BunbunBroll.Services.ToastService ToastService
@inject GenerationEventBus EventBus
@inject IIntelligenceService IntelligenceService
@inject IAssetBroker AssetBroker
@inject WhiskImageGenerator WhiskGenerator
@inject KenBurnsService KenBurnsService
@inject IShortVideoComposer VideoComposer
@inject IDownloaderService DownloaderService
@inject VideoStyleSettings StyleSettings

<div class="max-w-[90rem] mx-auto pt-6 pb-8 px-4">
    <nav class="breadcrumb mb-6 flex justify-between items-center text-sm">
        <div class="flex items-center gap-2">
            @if (_currentView == "list")
            {
                <span class="breadcrumb-current font-semibold text-lg">Script Dashboard</span>
            }
            else
            {
                <a href="javascript:void(0)" @onclick="HandleBackToList" class="text-muted-foreground hover:text-primary transition-colors">Script Dashboard</a>
                <span class="text-muted-foreground/30">/</span>
                <span class="breadcrumb-current font-medium">@GetBreadcrumbTitle()</span>
            }
        </div>
    </nav>

    @* ============ VIEW 0: Session List ============ *@
    @if (_currentView == "list")
    {
        <SessionListView 
            Sessions="_sessions"
            BRollSummaries="_brollSummaries"
            IsLoading="_isLoadingSessions"
            IsSessionRunning="BgService.IsRunning"
            GetActiveJob="(id) => BgService.GetActiveJobs().GetValueOrDefault(id)"
            OnShowBatchForm="ShowBatchForm"
            OnShowConfigForm="ShowConfigForm"
            OnViewSession="HandleViewSession"
            OnDeleteSession="HandleDeleteSession" />
    }

    @* ============ VIEW 1: Config Form ============ *@
    @if (_currentView == "config")
    {
        <ConfigFormView 
            @bind-ChannelName="_channelName"
            @bind-SelectedPatternId="_selectedPatternId"
            @bind-Topic="_topic"
            @bind-Outline="_outline"
            @bind-SourceReferences="_sourceReferences"
            @bind-TargetDuration="_targetDuration"
            ChannelNames="_channelNames"
            AvailablePatterns="_availablePatterns"
            IsGenerating="_isGenerating"
            ErrorMessage="@_errorMessage"
            OnBack='() => _currentView = "list"'
            OnGenerate="HandleGenerate" />
    }

    @* ============ VIEW 2: Progress ============ *@
    @if (_currentView == "progress")
    {
        <GenerationProgressView 
            Topic="@_topic"
            SessionId="@_sessionId"
            ProgressMessage="@_progressMessage"
            Outline="@_outline"
            ProgressPercent="(int)_progressPercent"
            CompletedPhases="_completedPhases"
            TotalPhases="_totalPhases"
            PhaseStatuses="_phaseStatuses.Select(p => new GenerationProgressView.PhaseStatusInfo 
            { 
                Name = p.Name, 
                Status = p.Status, 
                DurationTarget = p.DurationTarget, 
                WordCount = p.WordCount,
                OutlinePoints = p.OutlinePoints 
            }).ToList()"
            ErrorMessage="@_errorMessage"
            CanCancel="_sessionId != null && BgService.IsRunning(_sessionId)"
            OnCancel="HandleCancelGeneration" />
    }

    @* ============ VIEW: Batch Gen-Configs ============ *@
    @if (_currentView == "batch")
    {
        <BatchConfigView 
            @bind-Theme="_batchTheme"
            @bind-ChannelName="_batchChannelName"
            @bind-Count="_batchCount"
            @bind-PatternId="_batchPatternId"
            @bind-Seed="_batchSeed"
            ChannelNames="_channelNames"
            AvailablePatterns="_availablePatterns"
            IsGenerating="_isBatchGenerating"
            ErrorMessage="@_batchError"
            Results="_batchResults"
            OnBack="HandleBackToList"
            OnGenerate="HandleBatchGenerate"
            OnUseAll="HandleUseAllConfigs"
            OnUseConfig="HandleUseConfig" />
    }

    @* ============ VIEW 3: Results ============ *@
    @if (_currentView == "results")
    {
        <ResultsView 
            Session="_resultSession"
            SessionId="@_sessionId"
            TotalWords="_totalWords"
            TotalMinutes="_totalMinutes"
            TotalPhases="_totalPhases"
            ValidatedCount="_validatedCount"
            Sections="_resultSections"
            IsRegeneratingAll="_isRegeneratingAll"
            IsExportingLrc="_isExportingLrc"
            ErrorMessage="@_errorMessage"
            LrcExportPath="@_lrcExportPath"
            OnBackToList="HandleBackToList"
            OnRegenerateAll="HandleRegenerateAll"
            OnEditConfig="HandleEditConfig"
            OnExportLrc="HandleExportLrc"
            OnSendToBroll="HandleSendToBroll"
            OnRegeneratePhase="HandleRegeneratePhase"
            OnCopyPhaseContent="HandleCopyPhaseContent"
            OnUpdatePhaseContent="HandleUpdatePhaseContent"
            OnImportSrt="HandleImportSrt" />
    }

    @* ============ VIEW 4: B-Roll Prompts ============ *@
    @if (_currentView == "broll-prompts")
    {
        <BrollPromptsView 
            Session="_resultSession"
            SessionId="@_sessionId"
            TotalWords="_totalWords"
            TotalMinutes="_totalMinutes"
            TotalPhases="_totalPhases"
            PromptItems="_brollPromptItems"
            IsClassifying="_isClassifyingBroll"
            ClassifyTotalSegments="_classifyTotalSegments"
            ClassifyCompletedSegments="_classifyCompletedSegments"
            ClassifyError="@_classifyError"
            IsSearchingBroll="_isSearchingBroll"
            IsRegeneratingAllKeywords="_isRegeneratingAllKeywords"
            IsGeneratingWhisk="_isGeneratingWhisk"
            WhiskGeneratedCount="_whiskGeneratedCount"
            WhiskTotalCount="_whiskTotalCount"
            OnBackToResults="HandleBackToResults"
            OnReclassify='() => RequestConfirmation("Reclassify All Prompts", "‚ö†Ô∏è DESTRUCTIVE: Ini akan me-reset SEMUA prompt dan klasifikasi media type (Video/Image) yang sudah ada. Apakah Anda yakin?", HandleReclassifyBroll)'
            OnRegenAllVideoKeywords='() => RequestConfirmation("Regen All Video Keywords", "Ini akan me-regenerate semua keyword untuk segment B-Roll Video via LLM. Prompt yang sudah ada akan diganti. Lanjutkan?", HandleRegenAllVideoKeywords)'
            OnSearchAllVideos='() => RequestConfirmation("Search All Videos", "Ini akan melakukan pencarian ulang untuk SEMUA segment video. Video yang sudah dipilih mungkin terganti. Apakah Anda yakin?", SearchBrollForAllSegmentsAsync)'
            OnGenerateAllWhiskImages="HandleGenerateAllWhiskImages"
            OnGenerateAllKenBurnsVideos="HandleGenerateAllKenBurnsVideos"
            OnResetAllImageStates='() => RequestConfirmation("Reset All Images", "üóëÔ∏è DESTRUCTIVE: Ini akan menghapus SEMUA image dan video. Anda harus men-generate ulang semuanya. Yakin?", HandleResetAllImageStates)'
            OnResetAllVideoStates='() => RequestConfirmation("Reset KB Videos", "‚ö†Ô∏è Ini akan menghapus semua video Ken Burns yang sudah jadi. Image asli tetap aman. Lanjutkan?", HandleResetAllVideoStates)'
            OnGeneratePrompts="RunClassifyOnly"
            OnGenerateImagePrompts="RunGenerateImagePrompts"
            OnGenerateKeywords="RunGenerateKeywords"
            IsGeneratingImagePrompts="_isGeneratingImagePrompts"
            ImagePromptGeneratedCount="_imagePromptGeneratedCount"
            ImagePromptTotalCount="_imagePromptTotalCount"
            IsGeneratingKeywords="_isGeneratingKeywords"
            KeywordGeneratedCount="_keywordGeneratedCount"
            KeywordTotalCount="_keywordTotalCount"
            OnToggleMediaType="HandleToggleMediaType"
            OnSearchSegment="HandleSearchSingleSegment"
            OnRegenSegmentKeywords="HandleRegenSegmentKeywords"
            OnRegenPromptAndImage="HandleRegenPromptAndImage"
            OnSelectVideo="HandleSelectVideo"
            OnApplyFilter="HandleApplyFilterToVideo"
            OnGenerateKenBurns="HandleGenerateKenBurnsVideo"
            OnResetSegmentVideo="HandleResetVideoStateForSegment"
            OnSave="SaveBrollPromptsToDisk"
            GetAssetUrl="GetAssetUrl"
            ResolveLocalPath="ResolveLocalPath"
            IsImportingSrt="_isImportingSrt"
            PromptConfig="_imagePromptConfig"
            GlobalContext="_globalContext"
            OnRegenerateContext="HandleRegenerateGlobalContext"
            OnImportSrt="HandleImportSrt"
            OnCookieUpdateRequested="HandleCookieUpdateRequested" />
    }
</div>

@* ============ Edit Config Modal ============ *@
<EditConfigModal 
    IsVisible="_showEditConfig"
    IsSaving="_isSavingConfig"
    ChannelNames="_channelNames"
    @bind-Topic="_editTopic"
    @bind-Outline="_editOutline"
    @bind-SourceReferences="_editSourceReferences"
    @bind-TargetDuration="_editTargetDuration"
    @bind-ChannelName="_editChannelName"
    OnClose="CancelEditConfig"
    OnSave="SaveAndRegenerateConfig" />

@* ============ Delete Confirmation Modal ============ *@
<DeleteConfirmModal 
    IsVisible="_showDeleteConfirm"
    IsDeleting="_isDeleting"
    Target="_deleteTarget"
    OnCancel="CancelDelete"
    OnConfirm="ConfirmDelete" />

@* ============ Global Confirmation Modal ============ *@
<ConfirmationModal 
    IsVisible="_showConfirmDialog"
    Title="@_confirmTitle"
    Message="@_confirmMessage"
    OnCancel="CancelConfirm"
    OnConfirm="ExecuteConfirm" />

@* ============ Update Whisk Cookie Modal ============ *@
@if (_showCookieModal)
{
    <div class="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-4">
        <div class="bg-background rounded-xl border border-border/50 shadow-2xl w-full max-w-lg overflow-hidden flex flex-col max-h-[90vh]">
            <div class="p-4 border-b border-border/50 bg-muted/30 flex justify-between items-center">
                <h3 class="text-lg font-semibold flex items-center gap-2">
                    <span class="text-amber-500">üç™</span> Update Whisk Cookie
                </h3>
            </div>
            
            <div class="p-6 space-y-4 overflow-y-auto">
                <p class="text-sm text-muted-foreground">
                    Your Google account cookie for Whisk image generation has expired or is invalid. 
                    Please paste a new one below to resume generation.
                </p>
                <div class="space-y-2">
                    <label class="text-xs font-semibold uppercase tracking-wider text-muted-foreground">New Cookie String</label>
                    <textarea class="input w-full min-h-[100px] text-sm font-mono bg-muted/30" 
                              @bind="_newWhiskCookie"
                              placeholder="Paste the full cookie string here..."></textarea>
                </div>
            </div>

            <div class="p-4 border-t border-border/50 bg-muted/30 flex justify-end gap-3 rounded-b-xl">
                <button class="btn-ghost" @onclick="CloseCookieModal">Cancel</button>
                <button class="btn-primary" 
                        disabled="@string.IsNullOrWhiteSpace(_newWhiskCookie)"
                        @onclick="SubmitCookieUpdate">
                    Update & Retry
                </button>
            </div>
        </div>
    </div>
}

@code {
    // Query parameters for deep linking (e.g. from /video page)
    [SupplyParameterFromQuery(Name = "sessionId")]
    public string? QuerySessionId { get; set; }

    [SupplyParameterFromQuery(Name = "view")]
    public string? QueryView { get; set; }

    // Views: list, config, progress, results, broll-prompts
    private string _currentView = "list";
    private List<ScriptGenerationSession> _sessions = new();
    private bool _isLoadingSessions = true;
    private Dictionary<string, BRollSummary> _brollSummaries = new();

    // Event bus subscriptions
    private IDisposable? _progressSubscription;
    private IDisposable? _listSubscription;

    // Config
    private List<ScriptPattern> _availablePatterns = new();
    private List<string> _channelNames = new();
    private string _selectedPatternId = "";
    private ScriptPattern? _selectedPattern => _availablePatterns.FirstOrDefault(p => p.Id == _selectedPatternId);
    private string _channelName = "";
    private string _topic = "";
    private string? _outline;
    private string? _sourceReferences;
    private int _targetDuration = 30;
    private bool _isGenerating = false;
    private bool _isCancelling = false;
    private string? _errorMessage;
    private string? _saveError;

    // Progress
    private string? _sessionId;
    private string? _progressMessage;
    private double _progressPercent;
    private int _completedPhases;
    private int _totalPhases;
    private List<PhaseStatusItem> _phaseStatuses = new();

    // Results
    private ScriptGenerationSession? _resultSession;
    private List<ResultSection> _resultSections = new();
    private int _totalWords;
    private int _totalMinutes;
    private int _validatedCount;
    private bool _isRegeneratingAll;
    private bool _isExportingLrc;
    private bool _isImportingSrt;
    private string? _lrcExportPath;

    // Broll Prompts
    private List<BrollPromptItem> _brollPromptItems = new();
    private ImagePromptConfig _imagePromptConfig = new();
    private GlobalScriptContext? _globalContext;
    private bool _isClassifyingBroll;
    private int _classifyTotalSegments;
    private int _classifyCompletedSegments;
    private string? _classifyError;
    private bool _isSearchingBroll;
    private bool _isRegeneratingAllKeywords;
    private bool _isGeneratingWhisk;
    private int _whiskGeneratedCount;
    private int _whiskTotalCount;
    private bool _isGeneratingImagePrompts;
    private int _imagePromptGeneratedCount;
    private int _imagePromptTotalCount;
    private bool _isGeneratingKeywords;
    private int _keywordGeneratedCount;
    private int _keywordTotalCount;

    // Delete
    private bool _showDeleteConfirm;
    private ScriptGenerationSession? _deleteTarget;

    // Batch Gen-Configs
    private string _batchTheme = "";
    private string _batchChannelName = "";
    private int _batchCount = 10;
    private string _batchPatternId = "";
    private string? _batchSeed;
    private bool _isBatchGenerating;
    private string? _batchError;
    private List<BatchConfigView.GeneratedConfig> _batchResults = new();
    private bool _isDeleting;

    // Edit Config
    private bool _showEditConfig;
    private bool _isSavingConfig;
    private string _editTopic = "";
    private string? _editOutline;

    // Cookie Update Modal
    private bool _showCookieModal;
    private string _newWhiskCookie = "";
    private BrollPromptItem? _cookieUpdateTargetItem;
    private string? _editSourceReferences;
    private int _editTargetDuration;
    private string _editChannelName = "";

    // Confirmation Modal State
    private bool _showConfirmDialog;
    private string _confirmTitle = "";
    private string _confirmMessage = "";
    private Func<Task>? _pendingConfirmAction;

    private readonly List<IDisposable> _listSubscriptions = new();

    private bool CanGenerate => !string.IsNullOrWhiteSpace(_topic)
        && !string.IsNullOrWhiteSpace(_selectedPatternId)
        && !string.IsNullOrWhiteSpace(_channelName)
        && !_isGenerating;

    protected override async Task OnInitializedAsync()
    {
        _channelNames = Configuration.GetSection("Channels").Get<List<string>>() ?? new List<string>();

        await LoadSessionsAsync();
        _availablePatterns = await ScriptService.GetAvailablePatternsAsync();
        if (_availablePatterns.Count == 1)
            _selectedPatternId = _availablePatterns[0].Id;
        if (_channelNames.Count == 1)
        {
            _channelName = _channelNames[0];
            _batchChannelName = _channelNames[0];
        }
        if (_availablePatterns.Count == 1)
            _batchPatternId = _availablePatterns[0].Id;

        if (!string.IsNullOrEmpty(QuerySessionId))
        {
            var session = await ScriptService.GetSessionAsync(QuerySessionId);
            if (session != null && session.Status == SessionStatus.Completed)
            {
                _sessionId = session.Id;
                _resultSession = session;
                _totalPhases = session.Phases.Count;
                await LoadResultSections(session);

                if (QueryView == "broll-prompts")
                {
                    await LoadBrollPromptsFromDisk();
                    _currentView = "broll-prompts";
                    if (_brollPromptItems.Any(i => i.MediaType == BrollMediaType.BrollVideo && i.SearchResults.Count == 0))
                    {
                        _ = Task.Run(async () =>
                        {
                            await InvokeAsync(async () =>
                            {
                                await SearchBrollForAllSegmentsAsync();
                                StateHasChanged();
                            });
                        });
                    }
                }
                else
                {
                    await LoadBrollPromptsFromDisk();
                    _currentView = "broll-prompts";
                    _ = AutoSearchMissingBrollSegments();
                }
                return;
            }
        }

        SubscribeToRunningSessionsForList();
    }

    private void SubscribeToRunningSessionsForList()
    {
        _listSubscription?.Dispose();
        foreach (var session in _sessions.Where(s => BgService.IsRunning(s.Id)))
        {
            SubscribeToSessionForList(session.Id);
        }
    }

    private void SubscribeToSessionForList(string sessionId)
    {
        var sub = EventBus.Subscribe(sessionId, evt =>
        {
            InvokeAsync(() =>
            {
                if (evt.Type == GenerationEventType.SessionCompleted ||
                    evt.Type == GenerationEventType.SessionFailed)
                {
                    _ = InvokeAsync(async () =>
                    {
                        await LoadSessionsAsync();
                        StateHasChanged();
                    });
                }
                else if (_currentView == "list")
                {
                    StateHasChanged();
                }
            });
        });
        _listSubscriptions.Add(sub);
    }

    private async Task LoadSessionsAsync()
    {
        _isLoadingSessions = true;
        try
        {
            _sessions = await ScriptService.ListSessionsAsync();
            await LoadBrollSummariesAsync();
        }
        catch { _sessions = new(); }
        finally { _isLoadingSessions = false; }
    }

    private async Task LoadBrollSummariesAsync()
    {
        _brollSummaries.Clear();
        foreach (var session in _sessions.Where(s => s.Status == SessionStatus.Completed))
        {
            try
            {
                var filePath = Path.Combine(session.OutputDirectory, "broll-prompts.json");
                if (!File.Exists(filePath)) continue;

                var json = await File.ReadAllTextAsync(filePath);
                var items = System.Text.Json.JsonSerializer.Deserialize<List<BrollPromptSaveItem>>(json, new System.Text.Json.JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true,
                    Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() }
                });

                if (items == null || items.Count == 0) continue;

                var summary = new BRollSummary
                {
                    TotalSegments = items.Count,
                    VideoCount = items.Count(i => i.MediaType == BrollMediaType.BrollVideo),
                    ImageGenCount = items.Count(i => i.MediaType == BrollMediaType.ImageGeneration),
                    VideosSelected = items.Count(i => !string.IsNullOrEmpty(i.SelectedVideoUrl)),
                    ImagesReady = items.Count(i => i.WhiskStatus == WhiskGenerationStatus.Done),
                    ThumbnailPaths = items
                        .Where(i => !string.IsNullOrEmpty(i.WhiskImagePath))
                        .Select(i => ResolveLocalPath(i.WhiskImagePath)) // Use resilient resolution
                        .Where(resolved => !string.IsNullOrEmpty(resolved) && File.Exists(resolved))
                        .Take(4)
                        .ToList()
                };
                _brollSummaries[session.Id] = summary;
            }
            catch { /* skip sessions with unreadable broll data */ }
        }
    }

    private string GetBreadcrumbTitle()
    {
        return _currentView switch
        {
            "config" => "Buat Script Baru",
            "batch" => "Batch Generate",
            "progress" => _topic ?? "Generating...",
            "results" => _resultSession?.Topic ?? "Script Editor",
            "broll-prompts" => _resultSession?.Topic ?? "B-Roll Prompts",
            _ => "Script Dashboard"
        };
    }

    private void ShowConfigForm()
    {
        _currentView = "config";
        _topic = "";
        _outline = null;
        _sourceReferences = null;
        _errorMessage = null;
    }

    private void ShowBatchForm()
    {
        _currentView = "batch";
        _batchTheme = "";
        _batchSeed = null;
        _batchError = null;
        _batchResults.Clear();
    }

    private async Task HandleBatchGenerate()
    {
        Console.WriteLine($"[DEBUG] HandleBatchGenerate called. Theme: '{_batchTheme}', Channel: '{_batchChannelName}'");
        
        if (string.IsNullOrWhiteSpace(_batchTheme) || string.IsNullOrWhiteSpace(_batchChannelName)) 
        {
            Console.WriteLine("[DEBUG] Validation failed: Theme or ChannelName is empty.");
            return;
        }

        // Find selected pattern
        var selectedPattern = _availablePatterns.FirstOrDefault(p => p.Id == _batchPatternId);
        if (selectedPattern == null)
        {
            _batchError = "Error: Pattern tidak valid atau belum dipilih.";
            Console.WriteLine("[DEBUG] Validation failed: Pattern invalid or not selected.");
            return;
        }

        _isBatchGenerating = true;
        _batchError = null;
        _batchResults.Clear();
        StateHasChanged();

        try
        {
            Console.WriteLine("[DEBUG] Calling BatchGenerator.GenerateConfigsAsync with sequential progress...");
            
            // Define progress callback
            Action<int, int> onProgress = (current, total) =>
            {
                _batchError = $"Generating config {current} of {total}...";
                InvokeAsync(StateHasChanged);
            };

            var configs = await BatchGenerator.GenerateConfigsAsync(_batchTheme, _batchChannelName, _batchCount, selectedPattern, _batchSeed, onProgress);
            Console.WriteLine($"[DEBUG] BatchGenerator returned {configs.Count} configs.");
            
            if (configs.Count == 0)
            {
                _batchError = "AI tidak menghasilkan config. Silakan coba lagi dengan tema yang berbeda atau spesifik.";
                Console.WriteLine("[DEBUG] Config count is 0. Set error message.");
            }
            else
            {
                _batchError = null; // Clear progress message
            }

            _batchResults = configs.Select(c => new BatchConfigView.GeneratedConfig
            {
                Topic = c.Topic,
                Outline = c.Outline,
                TargetDurationMinutes = c.TargetDurationMinutes,
                SourceReferences = c.SourceReferences,
                MustHaveBeats = c.MustHaveBeats,
                ChannelName = c.ChannelName
            }).ToList();
        }
        catch (Exception ex) 
        { 
            _batchError = $"Gagal: {ex.Message}"; 
            Console.WriteLine($"[DEBUG] Exception caught: {ex.Message}");
            Console.WriteLine(ex.StackTrace);
        }
        finally 
        { 
            _isBatchGenerating = false; 
            StateHasChanged(); 
            Console.WriteLine("[DEBUG] HandleBatchGenerate finished. isGenerating=false");
        }
    }

    private void HandleUseConfig(BatchConfigView.GeneratedConfig config)
    {
        _topic = config.Topic;
        _outline = config.Outline;
        
        if (config.MustHaveBeats?.Count > 0)
        {
            var beats = string.Join("\n", config.MustHaveBeats.Select(b => $"- {b}"));
            if (!string.IsNullOrWhiteSpace(_outline))
                _outline += "\n\n### MUST HAVE BEATS:\n" + beats;
            else
                _outline = "### MUST HAVE BEATS:\n" + beats;
        }

        _sourceReferences = config.SourceReferences;
        _targetDuration = config.TargetDurationMinutes;
        _channelName = config.ChannelName;
        _selectedPatternId = !string.IsNullOrEmpty(_batchPatternId) ? _batchPatternId : _selectedPatternId;
        _errorMessage = null;
        _currentView = "config";
    }

    private void HandleUseAllConfigs()
    {
        if (_batchResults.Count > 0)
            HandleUseConfig(_batchResults[0]);
    }

    private void HandleEditConfig()
    {
        if (_resultSession == null) return;
        _editTopic = _resultSession.Topic;
        _editOutline = _resultSession.Outline;
        _editSourceReferences = _resultSession.SourceReferences;
        _editTargetDuration = _resultSession.TargetDurationMinutes;
        _editChannelName = _resultSession.ChannelName;
        _showEditConfig = true;
    }

    private void CancelEditConfig()
    {
        _showEditConfig = false;
        _isSavingConfig = false;
    }

    private async Task SaveAndRegenerateConfig()
    {
        if (_resultSession == null) return;
        _isSavingConfig = true;
        _errorMessage = null;

        try
        {
            var config = new ScriptConfig
            {
                Topic = _editTopic,
                Outline = _editOutline,
                TargetDurationMinutes = _editTargetDuration,
                SourceReferences = _editSourceReferences,
                ChannelName = _editChannelName
            };

            Console.WriteLine($"[DEBUG] SaveAndRegenerateConfig: Sending TargetDurationMinutes = {_editTargetDuration}");

            await ScriptService.UpdateSessionAsync(_resultSession.Id, config);
            
            _resultSession.Topic = config.Topic;
            _resultSession.Outline = config.Outline;
            _resultSession.TargetDurationMinutes = config.TargetDurationMinutes;
            _resultSession.SourceReferences = config.SourceReferences;
            _resultSession.ChannelName = config.ChannelName;
            
            _showEditConfig = false;
            await HandleRegenerateAll();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Gagal menyimpan config: {ex.Message}";
        }
        finally
        {
            _isSavingConfig = false;
            StateHasChanged();
        }
    }

    private void HandleDeleteSession(ScriptGenerationSession session)
    {
        _deleteTarget = session;
        _showDeleteConfirm = true;
    }

    private void CancelDelete()
    {
        _showDeleteConfirm = false;
        _deleteTarget = null;
    }

    private async Task ConfirmDelete()
    {
        if (_deleteTarget == null) return;
        _isDeleting = true;
        try
        {
            await ScriptService.DeleteSessionAsync(_deleteTarget.Id);
            _sessions.Remove(_deleteTarget);
        }
        catch (Exception ex) { _errorMessage = $"Gagal menghapus: {ex.Message}"; }
        finally
        {
            _isDeleting = false;
            _showDeleteConfirm = false;
            _deleteTarget = null;
            StateHasChanged();
        }
    }

    private async Task HandleViewSession(ScriptGenerationSession session)
    {
        _sessionId = session.Id;
        _resultSession = session;
        _totalPhases = session.Phases.Count;

        if (session.Status == SessionStatus.Completed)
        {
            await LoadResultSections(session);
            await LoadBrollPromptsFromDisk();
            _currentView = "broll-prompts";
            _ = AutoSearchMissingBrollSegments();
        }
        else if (session.Status == SessionStatus.Running || session.Status == SessionStatus.Failed || BgService.IsRunning(session.Id))
        {
            _phaseStatuses = session.Phases.OrderBy(p => p.Order).Select(p => new PhaseStatusItem
            {
                PhaseId = p.PhaseId, Name = p.PhaseName, Order = p.Order,
                Status = p.Status.ToString(), WordCount = p.WordCount ?? 0
            }).ToList();
            _completedPhases = session.Phases.Count(p => p.Status == PhaseStatus.Completed);
            _progressPercent = _totalPhases > 0 ? (double)_completedPhases / _totalPhases * 100 : 0;
            _progressMessage = session.ErrorMessage ?? "Sedang berjalan...";
            _errorMessage = session.Status == SessionStatus.Failed ? session.ErrorMessage : null;
            _currentView = "progress";

            if (BgService.IsRunning(session.Id))
            {
                SubscribeToProgress(session.Id);
            }
        }
    }

    private async Task LoadResultSections(ScriptGenerationSession session)
    {
        _resultSections.Clear();
        
        Dictionary<string, List<string>> outlineDist = new();
        if (!string.IsNullOrEmpty(session.OutlineDistributionJson))
        {
            try { outlineDist = System.Text.Json.JsonSerializer.Deserialize<Dictionary<string, List<string>>>(session.OutlineDistributionJson) ?? new(); }
            catch { }
        }

        foreach (var phase in session.Phases.OrderBy(p => p.Order))
        {
            var content = "";
            var isMissing = false;
            var debugInfo = "";

            if (!string.IsNullOrEmpty(phase.ContentFilePath) && File.Exists(phase.ContentFilePath))
            {
                content = await File.ReadAllTextAsync(phase.ContentFilePath);
            }
            else if (!string.IsNullOrEmpty(phase.ContentFilePath) && File.Exists(Path.Combine(Directory.GetCurrentDirectory(), phase.ContentFilePath)))
            {
                content = await File.ReadAllTextAsync(Path.Combine(Directory.GetCurrentDirectory(), phase.ContentFilePath));
            }
            else
            {
                var expectedPath = Path.Combine(Directory.GetCurrentDirectory(), "output", session.Id, "scripts", $"{phase.Order:D2}-{phase.PhaseId}.md");
                if (File.Exists(expectedPath))
                {
                    content = await File.ReadAllTextAsync(expectedPath);
                }
                else
                {
                    isMissing = true;
                    debugInfo = $"DB Path: '{phase.ContentFilePath}'\nCWD: '{Directory.GetCurrentDirectory()}'\nTried constructed: '{expectedPath}'";
                }
            }

            List<string>? points = null;
            if (outlineDist.TryGetValue(phase.PhaseId, out var pts)) points = pts;

            _resultSections.Add(new ResultSection
            {
                PhaseId = phase.PhaseId,
                PhaseName = phase.PhaseName,
                Order = phase.Order,
                Content = isMissing ? debugInfo : content,
                WordCount = phase.WordCount ?? 0,
                DurationSeconds = phase.DurationSeconds ?? 0,
                IsValidated = phase.IsValidated,
                IsExpanded = true,
                OutlinePoints = points,
                IsFileMissing = isMissing
            });
        }
        _totalWords = session.Phases.Sum(p => p.WordCount ?? 0);
        _totalMinutes = (int)(session.Phases.Sum(p => p.DurationSeconds ?? 0) / 60);
        _validatedCount = session.Phases.Count(p => p.IsValidated);
    }

    private async Task HandleGenerate()
    {
        if (!CanGenerate) return;

        if (_sessionId != null && BgService.IsRunning(_sessionId))
        {
            _errorMessage = "Session ini sedang dalam proses generasi. Tunggu sampai selesai atau batalkan dulu.";
            return;
        }

        _isGenerating = true;
        _errorMessage = null;

        try
        {
            var session = await ScriptService.CreateSessionAsync(_selectedPatternId, _topic, _outline, _targetDuration, _sourceReferences, _channelName);
            _sessionId = session.Id;
            _totalPhases = session.Phases.Count;
            _completedPhases = 0;
            _progressPercent = 0;
            _progressMessage = "Mempersiapkan...";

            _phaseStatuses = session.Phases.OrderBy(p => p.Order).Select(p => new PhaseStatusItem
            {
                PhaseId = p.PhaseId, Name = p.PhaseName, Order = p.Order, Status = "Pending"
            }).ToList();

            _currentView = "progress";
            StateHasChanged();

            SubscribeToProgress(session.Id);
            SubscribeToSessionForList(session.Id);
            BgService.EnqueueGeneration(session.Id);
        }
        catch (Exception ex) { _errorMessage = $"Error: {ex.Message}"; }
        finally { _isGenerating = false; StateHasChanged(); }
    }

    private void SubscribeToProgress(string sessionId)
    {
        _progressSubscription?.Dispose();
        _progressSubscription = EventBus.Subscribe(sessionId, evt =>
        {
            InvokeAsync(() =>
            {
                switch (evt.Type)
                {
                    case GenerationEventType.PhaseStarted:
                    case GenerationEventType.PhaseCompleted:
                    case GenerationEventType.PhaseFailed:
                        var phase = _phaseStatuses.FirstOrDefault(p => p.PhaseId == evt.PhaseId);
                        if (phase != null)
                        {
                            phase.Status = evt.PhaseStatus ?? evt.Type.ToString();
                            if (evt.OutlinePoints?.Count > 0)
                                phase.OutlinePoints = evt.OutlinePoints;
                            if (!string.IsNullOrEmpty(evt.DurationTarget))
                                phase.DurationTarget = evt.DurationTarget;
                        }
                        _progressMessage = evt.Message;
                        break;

                    case GenerationEventType.SessionProgress:
                        _completedPhases = evt.CompletedPhases;
                        _totalPhases = evt.TotalPhases;
                        _progressPercent = evt.ProgressPercent;
                        _progressMessage = evt.Message;
                        break;

                    case GenerationEventType.SessionCompleted:
                        _progressSubscription?.Dispose();
                        _ = InvokeAsync(async () =>
                        {
                            var completedSession = await ScriptService.GetSessionAsync(sessionId);
                            if (completedSession != null)
                            {
                                _resultSession = completedSession;
                                await LoadResultSections(completedSession);
                                await LoadBrollPromptsFromDisk();
                                _currentView = "broll-prompts";
                                _ = AutoSearchMissingBrollSegments();
                            }
                            StateHasChanged();
                        });
                        break;

                    case GenerationEventType.SessionFailed:
                        _progressSubscription?.Dispose();
                        _errorMessage = evt.Message;
                        break;
                }
                StateHasChanged();
            });
        });
    }

    private async Task HandleRegeneratePhase(ResultSection section)
    {
        if (section.IsRegenerating || _sessionId == null) return;
        section.IsRegenerating = true;
        StateHasChanged();

        try
        {
            var session = await ScriptService.RegeneratePhaseAsync(_sessionId, section.PhaseId);
            _resultSession = session;

            var updatedPhase = session.Phases.FirstOrDefault(p => p.PhaseId == section.PhaseId);
            if (updatedPhase != null)
            {
                if (!string.IsNullOrEmpty(updatedPhase.ContentFilePath) && File.Exists(updatedPhase.ContentFilePath))
                    section.Content = await File.ReadAllTextAsync(updatedPhase.ContentFilePath);
                section.WordCount = updatedPhase.WordCount ?? 0;
                section.DurationSeconds = updatedPhase.DurationSeconds ?? 0;
                section.IsValidated = updatedPhase.IsValidated;
                section.IsExpanded = true;
            }

            _totalWords = session.Phases.Sum(p => p.WordCount ?? 0);
            _totalMinutes = (int)(session.Phases.Sum(p => p.DurationSeconds ?? 0) / 60);
            _validatedCount = session.Phases.Count(p => p.IsValidated);
        }
        catch (Exception ex) { _errorMessage = $"Regenerate gagal: {ex.Message}"; }
        finally { section.IsRegenerating = false; StateHasChanged(); }

        InvalidateBrollClassification();
    }

    private async Task HandleRegenerateAll()
    {
        if (_isRegeneratingAll || _sessionId == null) return;

        if (BgService.IsRunning(_sessionId))
        {
            _errorMessage = "Generasi masih berjalan. Tunggu sampai selesai atau batalkan dulu.";
            StateHasChanged();
            return;
        }

        _isRegeneratingAll = true;
        _errorMessage = null;
        InvalidateBrollClassification();
        StateHasChanged();

        try
        {
            _progressMessage = "Mempersiapkan regenerasi...";
            _completedPhases = 0;
            _progressPercent = 0;

            // Reset all phases to Pending so they regenerate with new config
            Console.WriteLine($"[DEBUG] HandleRegenerateAll: Resetting phases for session {_sessionId}");
            await ScriptService.ResetSessionPhasesAsync(_sessionId);

            _phaseStatuses = _resultSections.Select(s => new PhaseStatusItem
            {
                PhaseId = s.PhaseId, Name = s.PhaseName, Order = s.Order, Status = "Pending"
            }).ToList();

            _currentView = "progress";
            StateHasChanged();

            _progressMessage = "Regenerating semua fase...";
            SubscribeToProgress(_sessionId);
            BgService.EnqueueGeneration(_sessionId);
        }
        catch (Exception ex) { _errorMessage = $"Regenerate All gagal: {ex.Message}"; }
        finally { _isRegeneratingAll = false; StateHasChanged(); }
    }

    private async Task HandleCopyPhaseContent(ResultSection section)
    {
        try
        {
            await JS.InvokeVoidAsync("copyToClipboard", section.Content);
            section.CopyState = "copied";
            StateHasChanged();

            _ = InvokeAsync(async () =>
            {
                await Task.Delay(2000);
                section.CopyState = "idle";
                StateHasChanged();
            });
        }
        catch { }
    }

    private async Task HandleCancelGeneration()
    {
        if (_isCancelling || string.IsNullOrEmpty(_sessionId)) return;
        _isCancelling = true;
        StateHasChanged();

        if (BgService.CancelGeneration(_sessionId))
        {
            _progressMessage = "Membatalkan generasi...";
            await Task.Delay(500);
        }
        else
        {
            _errorMessage = "Tidak bisa membatalkan: generasi tidak sedang berjalan.";
        }

        _isCancelling = false;
        StateHasChanged();
    }

    public void Dispose()
    {
        _progressSubscription?.Dispose();
        _listSubscription?.Dispose();
        foreach (var sub in _listSubscriptions)
            sub.Dispose();
        _listSubscriptions.Clear();
    }

    private async Task HandleBackToList() { await LoadSessionsAsync(); _currentView = "list"; _errorMessage = null; }
    private void HandleBackToResults() { _currentView = "results"; _classifyError = null; }

    private async Task HandleSendToBroll()
    {
        if (_resultSession == null || _resultSections.Count == 0) return;

        if (_brollPromptItems.Count == 0)
        {
            await LoadBrollPromptsFromDisk();
            await LoadImageConfigFromDisk();
        }

        _currentView = "broll-prompts";
        StateHasChanged();
    }

    private async Task RunClassifyOnly()
    {
        if (_resultSession == null) return;

        _isClassifyingBroll = true;
        _classifyError = null;
        _classifyTotalSegments = 0;
        _classifyCompletedSegments = 0;
        StateHasChanged();

        try
        {
            var segments = new List<(string Timestamp, string ScriptText)>();

            // Check if we already have segments from SRT import (have ScriptText but no Prompt yet)
            var hasImportedSegments = _brollPromptItems.Count > 0 
                && _brollPromptItems.All(i => string.IsNullOrEmpty(i.Prompt));

            if (hasImportedSegments)
            {
                // Reuse existing imported segments ‚Äî don't re-parse from _resultSections
                segments = _brollPromptItems
                    .Select(i => (i.Timestamp, i.ScriptText))
                    .ToList();
            }
            else
            {
                // Parse segments from script result sections (original flow)
                if (_resultSections.Count == 0) return;
                _brollPromptItems.Clear();

                var timestampPattern = new System.Text.RegularExpressions.Regex(@"\[(\d{1,3}):(\d{2})\]", System.Text.RegularExpressions.RegexOptions.Compiled);
                var globalOffset = TimeSpan.Zero;

                foreach (var section in _resultSections.OrderBy(s => s.Order))
                {
                    if (string.IsNullOrWhiteSpace(section.Content)) continue;
                    var entries = ParseTimestampedEntries(section.Content, timestampPattern);

                    if (entries.Count > 0)
                    {
                        var phaseBase = entries[0].Timestamp;
                        foreach (var entry in entries)
                        {
                            var normalizedTime = entry.Timestamp - phaseBase;
                            if (normalizedTime < TimeSpan.Zero) normalizedTime = TimeSpan.Zero;
                            var absoluteTime = globalOffset.Add(normalizedTime);
                            var cleaned = CleanSubtitleText(entry.Text);
                            if (string.IsNullOrWhiteSpace(cleaned)) continue;
                            var mins = (int)absoluteTime.TotalMinutes;
                            var secs = absoluteTime.Seconds;
                            segments.Add(($"[{mins:D2}:{secs:D2}]", cleaned));
                        }
                        var lastEntry = entries.Last();
                        var normalizedLastTime = lastEntry.Timestamp - phaseBase;
                        if (normalizedLastTime < TimeSpan.Zero) normalizedLastTime = TimeSpan.Zero;
                        var lastDuration = EstimateDuration(lastEntry.Text);
                        globalOffset = globalOffset.Add(normalizedLastTime).Add(TimeSpan.FromSeconds(lastDuration));
                    }
                    else
                    {
                        var cleaned = CleanSubtitleText(section.Content);
                        if (!string.IsNullOrWhiteSpace(cleaned))
                        {
                            var mins = (int)globalOffset.TotalMinutes;
                            var secs = globalOffset.Seconds;
                            segments.Add(($"[{mins:D2}:{secs:D2}]", cleaned));
                            globalOffset = globalOffset.Add(TimeSpan.FromSeconds(EstimateDuration(cleaned)));
                        }
                    }
                }
            }

            if (segments.Count == 0)
            {
                _classifyError = "Tidak ada segment yang bisa diproses.";
                _isClassifyingBroll = false;
                StateHasChanged();
                return;
            }

            _classifyTotalSegments = segments.Count;
            await InvokeAsync(StateHasChanged);

            // Classification ONLY ‚Äî no prompt generation
            _brollPromptItems = await IntelligenceService.ClassifySegmentsOnlyAsync(
                segments, _resultSession.Topic,
                config: _imagePromptConfig,
                onBatchComplete: async batchResults =>
                {
                    _brollPromptItems = batchResults.OrderBy(r => r.Index).ToList();
                    _classifyCompletedSegments = batchResults.Count;
                    await InvokeAsync(StateHasChanged);
                });
        }
        catch (Exception ex)
        {
            _classifyError = $"Gagal mengklasifikasi: {ex.Message}";
        }
        finally
        {
            _isClassifyingBroll = false;
            StateHasChanged();
        }

        // OVERRIDE: Force ImageGeneration for Phase 1 & 2 (visual hooking) if enabled in config
        if (_imagePromptConfig.ForceVisualHook)
        {
            foreach (var item in _brollPromptItems)
            {
                if (TryParseTimestamp(item.Timestamp, out var timestamp))
                {
                    var phaseId = PhaseDetectionService.DetectPhase(timestamp);
                    if (phaseId == "opening-hook" || phaseId == "contextualization")
                    {
                        item.MediaType = BrollMediaType.ImageGeneration;
                        item.Reasoning = $"Phase {phaseId}: Forced to ImageGeneration for visual hooking";
                    }
                }
            }
        }

        await SaveBrollPromptsToDisk();
        await SaveImageConfigToDisk();
    }

    private async Task RunGenerateImagePrompts()
    {
        if (_resultSession == null || _brollPromptItems.Count == 0) return;

        var imageItems = _brollPromptItems.Where(i => i.MediaType == BrollMediaType.ImageGeneration).ToList();
        if (imageItems.Count == 0) return;

        _isGeneratingImagePrompts = true;
        _imagePromptTotalCount = imageItems.Count;
        _imagePromptGeneratedCount = 0;
        StateHasChanged();

        try
        {
            // Pass 1: Extract global context if needed
            if (_globalContext == null || _globalContext.Topic != _resultSession.Topic)
            {
                _classifyError = null;
                StateHasChanged();

                _globalContext = await IntelligenceService.ExtractGlobalContextAsync(
                    _brollPromptItems, _resultSession.Topic);
            }

            if (_globalContext != null)
            {
                // Pass 2: Context-aware generation
                await IntelligenceService.GeneratePromptsWithContextAsync(
                    _brollPromptItems, BrollMediaType.ImageGeneration,
                    _resultSession.Topic, _globalContext, _imagePromptConfig,
                    onProgress: async count =>
                    {
                        _imagePromptGeneratedCount = count;
                        await InvokeAsync(StateHasChanged);
                    },
                    windowSize: 2);
            }
            else
            {
                // Fallback: non-context-aware generation
                await IntelligenceService.GeneratePromptsForTypeBatchAsync(
                    _brollPromptItems, BrollMediaType.ImageGeneration,
                    _resultSession.Topic, _imagePromptConfig,
                    onProgress: async count =>
                    {
                        _imagePromptGeneratedCount = count;
                        await InvokeAsync(StateHasChanged);
                    });
            }
        }
        catch (Exception ex)
        {
            _classifyError = $"Gagal generate image prompts: {ex.Message}";
        }
        finally
        {
            _isGeneratingImagePrompts = false;
            StateHasChanged();
        }

        await SaveBrollPromptsToDisk();
        await SaveImageConfigToDisk();
    }

    private async Task RunGenerateKeywords()
    {
        if (_resultSession == null || _brollPromptItems.Count == 0) return;

        var brollItems = _brollPromptItems.Where(i => i.MediaType == BrollMediaType.BrollVideo).ToList();
        if (brollItems.Count == 0) return;

        _isGeneratingKeywords = true;
        _keywordTotalCount = brollItems.Count;
        _keywordGeneratedCount = 0;
        StateHasChanged();

        try
        {
            // Pass 1: Extract global context if needed
            if (_globalContext == null || _globalContext.Topic != _resultSession.Topic)
            {
                _classifyError = null;
                StateHasChanged();

                _globalContext = await IntelligenceService.ExtractGlobalContextAsync(
                    _brollPromptItems, _resultSession.Topic);
            }

            if (_globalContext != null)
            {
                // Pass 2: Context-aware generation
                await IntelligenceService.GeneratePromptsWithContextAsync(
                    _brollPromptItems, BrollMediaType.BrollVideo,
                    _resultSession.Topic, _globalContext, _imagePromptConfig,
                    onProgress: async count =>
                    {
                        _keywordGeneratedCount = count;
                        await InvokeAsync(StateHasChanged);
                    },
                    windowSize: 2);
            }
            else
            {
                // Fallback: non-context-aware generation
                await IntelligenceService.GeneratePromptsForTypeBatchAsync(
                    _brollPromptItems, BrollMediaType.BrollVideo,
                    _resultSession.Topic, _imagePromptConfig,
                    onProgress: async count =>
                    {
                        _keywordGeneratedCount = count;
                        await InvokeAsync(StateHasChanged);
                    });
            }
        }
        catch (Exception ex)
        {
            _classifyError = $"Gagal generate keywords: {ex.Message}";
        }
        finally
        {
            _isGeneratingKeywords = false;
            StateHasChanged();
        }

        await SaveBrollPromptsToDisk();

        // Auto-search for B-Roll videos after keywords are generated
        if (_brollPromptItems.Any(i => i.MediaType == BrollMediaType.BrollVideo && !string.IsNullOrEmpty(i.Prompt)))
        {
            await SearchBrollForAllSegmentsAsync();
        }
    }

    private async Task HandleReclassifyBroll()
    {
        InvalidateBrollClassification();
        await RunClassifyOnly();
    }

    private async Task HandleSelectVideo((BrollPromptItem item, VideoAsset video) args)
    {
        args.item.SelectedVideoUrl = args.video.DownloadUrl;
        await SaveBrollPromptsToDisk();
        StateHasChanged();
    }

    private async Task SearchBrollForAllSegmentsAsync()
    {
        _isSearchingBroll = true;
        StateHasChanged();

        var brollItems = _brollPromptItems.Where(i => i.MediaType == BrollMediaType.BrollVideo).ToList();
        foreach (var item in brollItems)
        {
            await SearchBrollForSegmentAsync(item, forceRefresh: true);
            StateHasChanged();
        }

        _isSearchingBroll = false;
        StateHasChanged();
    }

    private async Task AutoSearchMissingBrollSegments()
    {
        var missingItems = _brollPromptItems
            .Where(i => i.MediaType == BrollMediaType.BrollVideo 
                     && (i.AllSearchResults == null || i.AllSearchResults.Count == 0)
                     && !i.IsSearching)
            .ToList();

        if (missingItems.Count == 0) return;

        await InvokeAsync(() =>
        {
            _isSearchingBroll = true;
            StateHasChanged();
        });

        foreach (var item in missingItems)
        {
            await InvokeAsync(async () =>
            {
                await SearchBrollForSegmentAsync(item, forceRefresh: true);
                StateHasChanged();
            });
            await Task.Delay(500);
        }

        await InvokeAsync(() =>
        {
            _isSearchingBroll = false;
            StateHasChanged();
        });
    }

    private async Task SearchBrollForSegmentAsync(BrollPromptItem item, bool forceRefresh = false)
    {
        item.IsSearching = true;
        item.SearchError = null;
        
        try
        {
            const int pageSize = 4;
            
            if (!forceRefresh && item.AllSearchResults.Count > 0)
            {
                var totalPages = (int)Math.Ceiling((double)item.AllSearchResults.Count / pageSize);
                item.SearchPage = (item.SearchPage + 1) % totalPages;
            }
            else
            {
                item.SearchPage = 0;
                var keywords = new List<string> { item.Prompt };
                var results = await AssetBroker.SearchVideosAsync(keywords, maxResults: 12);
                item.AllSearchResults = results;
            }
            
            item.SearchResults = item.AllSearchResults
                .Skip(item.SearchPage * pageSize)
                .Take(pageSize)
                .ToList();
        }
        catch (Exception ex)
        {
            item.SearchError = $"Search gagal: {ex.Message}";
        }
        finally
        {
            item.IsSearching = false;
        }
    }

    private async Task HandleSearchSingleSegment(BrollPromptItem item)
    {
        await SearchBrollForSegmentAsync(item);
        StateHasChanged();
    }

    private async Task HandleToggleMediaType(BrollPromptItem item)
    {
        if (_resultSession == null) return;

        var newType = item.MediaType == BrollMediaType.BrollVideo ? BrollMediaType.ImageGeneration : BrollMediaType.BrollVideo;
        item.MediaType = newType;
        item.SearchResults.Clear();
        item.SearchError = null;
        item.SelectedVideoUrl = null;
        item.WhiskStatus = WhiskGenerationStatus.Pending;
        item.WhiskImagePath = null;
        item.WhiskError = null;
        item.IsSearching = true;
        StateHasChanged();

        try
        {
            var singleResult = await IntelligenceService.ClassifyAndGeneratePromptsAsync(
                new List<(string, string)> { (item.Timestamp, item.ScriptText) },
                _resultSession.Topic);

            if (singleResult.Count > 0)
            {
                item.Prompt = singleResult[0].Prompt;
                item.Reasoning = singleResult[0].Reasoning;
                item.MediaType = newType;
            }

            if (newType == BrollMediaType.BrollVideo)
            {
                await SearchBrollForSegmentAsync(item, forceRefresh: true);
            }
        }
        catch (Exception ex)
        {
            item.SearchError = $"Gagal generate prompt: {ex.Message}";
        }
        finally
        {
            item.IsSearching = false;
            await SaveBrollPromptsToDisk();
            StateHasChanged();
        }
    }

    private async Task HandleRegenerateGlobalContext()
    {
        if (_resultSession == null || _brollPromptItems.Count == 0) return;

        _classifyError = null;
        StateHasChanged();

        try
        {
            _globalContext = await IntelligenceService.ExtractGlobalContextAsync(
                _brollPromptItems, _resultSession.Topic);

            if (_globalContext == null)
            {
                _classifyError = "Failed to extract global context. Please try again.";
            }
        }
        catch (Exception ex)
        {
            _classifyError = $"Context extraction failed: {ex.Message}";
        }
        finally
        {
            StateHasChanged();
        }
    }

    private async Task HandleRegenSegmentKeywords(BrollPromptItem item)
    {
        if (_resultSession == null) return;

        item.IsSearching = true;
        StateHasChanged();

        try
        {
            string? brollKeywords;

            if (_globalContext != null)
            {
                brollKeywords = await IntelligenceService.GeneratePromptWithContextAsync(
                    item, _brollPromptItems, _resultSession.Topic,
                    _globalContext, _imagePromptConfig, windowSize: 2);
            }
            else
            {
                brollKeywords = await IntelligenceService.GeneratePromptForTypeAsync(
                    item.ScriptText, BrollMediaType.BrollVideo, _resultSession.Topic, config: _imagePromptConfig);
            }

            if (!string.IsNullOrWhiteSpace(brollKeywords))
            {
                item.Prompt = brollKeywords;
                item.Reasoning = "Regenerated keywords" + (_globalContext != null ? " (with context)" : "");
            }
            else
            {
                throw new Exception("AI failed to generate keywords. Please try again.");
            }

            if (item.MediaType == BrollMediaType.BrollVideo)
            {
                await SearchBrollForSegmentAsync(item, forceRefresh: true);
            }
        }
        catch (Exception ex)
        {
            item.SearchError = $"Regen gagal: {ex.Message}";
        }
        finally
        {
            item.IsSearching = false;
            StateHasChanged();
        }
    }

    private void HandleCookieUpdateRequested(BrollPromptItem item)
    {
        _cookieUpdateTargetItem = item;
        _newWhiskCookie = "";
        _showCookieModal = true;
    }

    private void CloseCookieModal()
    {
        _showCookieModal = false;
        _newWhiskCookie = "";
        _cookieUpdateTargetItem = null;
    }

    private async Task SubmitCookieUpdate()
    {
        if (string.IsNullOrWhiteSpace(_newWhiskCookie)) return;

        WhiskGenerator.UpdateCookie(_newWhiskCookie);
        
        var target = _cookieUpdateTargetItem;
        CloseCookieModal();

        if (target != null)
        {
            // Retry generating the image
            _ = Task.Run(async () =>
            {
                await InvokeAsync(() =>
                {
                    target.IsGenerating = true;
                    StateHasChanged();
                });

                await GenerateWhiskImageForItem(target);

                await InvokeAsync(() =>
                {
                    target.IsGenerating = false;
                    StateHasChanged();
                    _ = SaveBrollPromptsToDisk();
                });
            });
        }
    }

    private async Task HandleRegenAllVideoKeywords()
    {
        if (_resultSession == null) return;

        var brollItems = _brollPromptItems.Where(i => i.MediaType == BrollMediaType.BrollVideo).ToList();
        if (brollItems.Count == 0) return;

        _isRegeneratingAllKeywords = true;
        StateHasChanged();

        try
        {
            var segments = brollItems.Select(i => (i.Timestamp, i.ScriptText)).ToList();

            var results = await IntelligenceService.ClassifyAndGeneratePromptsAsync(
                segments, _resultSession.Topic,
                onBatchComplete: async batchResults =>
                {
                    foreach (var result in batchResults)
                    {
                        var matchingItem = brollItems.ElementAtOrDefault(result.Index);
                        if (matchingItem != null)
                        {
                            matchingItem.Prompt = result.Prompt;
                            matchingItem.Reasoning = result.Reasoning;
                            matchingItem.AllSearchResults.Clear();
                            matchingItem.SearchResults.Clear();
                        }
                    }
                    _classifyCompletedSegments = batchResults.Count;
                    await InvokeAsync(StateHasChanged);
                });

            for (int i = 0; i < results.Count && i < brollItems.Count; i++)
            {
                var item = brollItems[i];
                var result = results[i];
                
                item.Prompt = result.Prompt;
                item.Reasoning = result.Reasoning;
                
                if (item.MediaType != result.MediaType)
                {
                    item.MediaType = result.MediaType;
                    
                    if (item.MediaType == BrollMediaType.ImageGeneration)
                    {
                        item.WhiskStatus = WhiskGenerationStatus.Pending;
                        item.WhiskImagePath = null;
                        item.WhiskError = null;
                        item.WhiskVideoStatus = WhiskGenerationStatus.Pending;
                        item.WhiskVideoPath = null;
                        item.WhiskVideoError = null;
                        item.IsGenerating = false;
                        item.IsConvertingVideo = false;
                        item.KenBurnsMotion = BrollPromptItem.GetRandomMotion();
                    }
                }

                item.AllSearchResults.Clear();
                item.SearchResults.Clear();
            }

            await SaveBrollPromptsToDisk();
            await SearchBrollForAllSegmentsAsync();
        }
        catch (Exception ex)
        {
            _classifyError = $"Regen all keywords gagal: {ex.Message}";
        }
        finally
        {
            _isRegeneratingAllKeywords = false;
            StateHasChanged();
        }
    }

    private async Task HandleRegenPromptAndImage(BrollPromptItem item)
    {
        if (_resultSession == null) return;

        item.IsGenerating = true;
        item.CombinedRegenProgress = 10;
        item.WhiskError = null;
        item.WhiskVideoStatus = WhiskGenerationStatus.Pending;
        item.WhiskVideoPath = null;
        item.WhiskVideoError = null;
        StateHasChanged();

        try
        {
            item.CombinedRegenProgress = 20;
            StateHasChanged();

            string? imagePrompt;

            if (_globalContext != null)
            {
                imagePrompt = await IntelligenceService.GeneratePromptWithContextAsync(
                    item, _brollPromptItems, _resultSession.Topic,
                    _globalContext, _imagePromptConfig, windowSize: 2);
            }
            else
            {
                imagePrompt = await IntelligenceService.GeneratePromptForTypeAsync(
                    item.ScriptText, BrollMediaType.ImageGeneration, _resultSession.Topic, config: _imagePromptConfig);
            }

            if (!string.IsNullOrWhiteSpace(imagePrompt))
            {
                item.Prompt = imagePrompt;
                item.Reasoning = "Regenerated image prompt" + (_globalContext != null ? " (with context)" : "");
                item.KenBurnsMotion = BrollPromptItem.GetRandomMotion();
            }
            else
            {
                throw new Exception("AI disconnected or failed to generate a new prompt. Please try again or check logs.");
            }

            item.CombinedRegenProgress = 50;
            StateHasChanged();

            item.CombinedRegenProgress = 70;
            StateHasChanged();

            await GenerateWhiskImageForItem(item);
            item.CombinedRegenProgress = 100;
        }
        catch (Exception ex)
        {
            item.WhiskStatus = WhiskGenerationStatus.Failed;
            item.WhiskError = ex.Message;
        }
        finally
        {
            item.IsGenerating = false;
            await SaveBrollPromptsToDisk();
            StateHasChanged();
        }
    }

    private async Task HandleGenerateAllWhiskImages()
    {
        var imageGenItems = _brollPromptItems
            .Where(i => i.MediaType == BrollMediaType.ImageGeneration && i.WhiskStatus != WhiskGenerationStatus.Done)
            .ToList();

        if (imageGenItems.Count == 0) return;

        _isGeneratingWhisk = true;
        _whiskTotalCount = imageGenItems.Count;
        _whiskGeneratedCount = 0;
        StateHasChanged();

        foreach (var item in imageGenItems)
        {
            item.IsGenerating = true;
            StateHasChanged();

            try
            {
                await GenerateWhiskImageForItem(item);
            }
            finally
            {
                item.IsGenerating = false;
                _whiskGeneratedCount++;
                StateHasChanged();
            }
        }

        _isGeneratingWhisk = false;
        await SaveBrollPromptsToDisk();
        StateHasChanged();
    }

    private async Task HandleGenerateKenBurnsVideo(BrollPromptItem item)
    {
        if (string.IsNullOrEmpty(item.WhiskImagePath) || !File.Exists(item.WhiskImagePath)) return;

        item.IsConvertingVideo = true;
        item.WhiskVideoError = null;
        item.WhiskVideoStatus = WhiskGenerationStatus.Generating;
        StateHasChanged();

        bool shouldApplyFilter = false;

        try
        {
            var duration = EstimateDuration(item.ScriptText);
            var outputDir = Path.GetDirectoryName(item.WhiskImagePath)!;
            var fileName = Path.GetFileNameWithoutExtension(item.WhiskImagePath) + "_kb.mp4";
            var outputPath = Path.Combine(outputDir, fileName);

            var success = await KenBurnsService.ConvertImageToVideoAsync(
                item.WhiskImagePath, outputPath, duration, 1920, 1080, item.KenBurnsMotion);

            if (success)
            {
                item.WhiskVideoPath = outputPath;
                item.WhiskVideoStatus = WhiskGenerationStatus.Done;
                shouldApplyFilter = item.HasVisualEffect;
            }
            else
            {
                item.WhiskVideoStatus = WhiskGenerationStatus.Failed;
                item.WhiskVideoError = "FFmpeg conversion failed ‚Äî check logs";
            }
        }
        catch (Exception ex)
        {
            item.WhiskVideoStatus = WhiskGenerationStatus.Failed;
            item.WhiskVideoError = ex.Message;
        }
        finally
        {
            item.IsConvertingVideo = false;
            await SaveBrollPromptsToDisk();
            StateHasChanged();
        }

        if (shouldApplyFilter)
        {
            await Task.Delay(50);
            await HandleApplyFilterToVideo(item);
        }
    }

    private async Task HandleResetAllImageStates()
    {
        foreach (var item in _brollPromptItems.Where(i => i.MediaType == BrollMediaType.ImageGeneration))
        {
            if (!string.IsNullOrEmpty(item.WhiskImagePath) && System.IO.File.Exists(item.WhiskImagePath))
            {
                try { System.IO.File.Delete(item.WhiskImagePath); } catch { }
                try { System.IO.File.Delete(item.WhiskVideoPath); } catch { }
            }

            item.WhiskStatus = WhiskGenerationStatus.Pending;
            item.WhiskImagePath = null;
            item.WhiskError = null;
            item.WhiskVideoStatus = WhiskGenerationStatus.Pending;
            item.WhiskVideoPath = null;
            item.WhiskVideoError = null;
            item.IsGenerating = false;
            item.IsConvertingVideo = false;
        }

        await SaveBrollPromptsToDisk();
        StateHasChanged();
    }

    private async Task HandleResetAllVideoStates()
    {
        foreach (var item in _brollPromptItems.Where(i => i.MediaType == BrollMediaType.ImageGeneration))
        {
            if (!string.IsNullOrEmpty(item.WhiskVideoPath) && System.IO.File.Exists(item.WhiskVideoPath))
            {
                try { System.IO.File.Delete(item.WhiskVideoPath); } catch { }
            }

            item.WhiskVideoStatus = WhiskGenerationStatus.Pending;
            item.WhiskVideoPath = null;
            item.WhiskVideoError = null;
            item.IsConvertingVideo = false;
        }

        await SaveBrollPromptsToDisk();
        StateHasChanged();
    }

    private async Task HandleResetVideoStateForSegment(BrollPromptItem item)
    {
        if (!string.IsNullOrEmpty(item.WhiskVideoPath) && System.IO.File.Exists(item.WhiskVideoPath))
        {
            try { System.IO.File.Delete(item.WhiskVideoPath); } catch { }
        }

        item.WhiskVideoStatus = WhiskGenerationStatus.Pending;
        item.WhiskVideoPath = null;
        item.WhiskVideoError = null;
        item.IsConvertingVideo = false;
        item.FilteredVideoPath = null;

        await SaveBrollPromptsToDisk();
        StateHasChanged();
    }

    private async Task HandleUpdatePhaseContent((ResultSection Section, string NewContent) args)
    {
        try
        {
            if (_resultSession == null) return;
            
            await ScriptService.UpdatePhaseContentAsync(_resultSession.Id, args.Section.PhaseId, args.NewContent);
            
            // Update local state
            args.Section.Content = args.NewContent;
            
            // Recalculate totals
            _totalWords = _resultSections.Sum(s => s.WordCount);
            // Simple re-estimation of duration
            var totalSeconds = _resultSections.Sum(s => s.DurationSeconds);
            _totalMinutes = (int)Math.Ceiling(totalSeconds / 60.0);
            
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Gagal menyimpan perubahan: {ex.Message}";
            Console.Error.WriteLine(ex);
        }
    }

    private async Task HandleGenerateAllKenBurnsVideos()
    {
        var pending = _brollPromptItems
            .Where(i => i.MediaType == BrollMediaType.ImageGeneration && 
                        i.WhiskStatus == WhiskGenerationStatus.Done && 
                        i.WhiskVideoStatus != WhiskGenerationStatus.Done &&
                        !i.IsConvertingVideo)
            .ToList();

        if (pending.Count == 0) return;

        foreach (var item in pending)
        {
            await HandleGenerateKenBurnsVideo(item);
        }
    }

    private async Task GenerateWhiskImageForItem(BrollPromptItem item)
    {
        item.WhiskStatus = WhiskGenerationStatus.Generating;
        item.WhiskError = null;
        item.WhiskVideoStatus = WhiskGenerationStatus.Pending;
        item.WhiskVideoPath = null;
        item.WhiskVideoError = null;
        StateHasChanged();

        try
        {
            // Use session's output directory for Whisk images
            var outputDir = !string.IsNullOrEmpty(_resultSession?.OutputDirectory)
                ? Path.Combine(_resultSession.OutputDirectory, "whisks_images")
                : Path.Combine(Directory.GetCurrentDirectory(), "output", _sessionId ?? "temp", "whisks_images");
            Directory.CreateDirectory(outputDir);

            using var cts = new CancellationTokenSource(TimeSpan.FromSeconds(120));
            var result = await WhiskGenerator.GenerateImageAsync(item.Prompt, outputDir, cancellationToken: cts.Token);
            if (result.Success)
            {
                item.WhiskStatus = WhiskGenerationStatus.Done;
                item.WhiskImagePath = result.ImagePath;
            }
            else
            {
                item.WhiskStatus = WhiskGenerationStatus.Failed;
                item.WhiskError = result.Error ?? "Unknown error";
            }
        }
        catch (OperationCanceledException)
        {
            item.WhiskStatus = WhiskGenerationStatus.Failed;
            item.WhiskError = "Timeout: generasi gambar melebihi 120 detik";
        }
        catch (Exception ex)
        {
            item.WhiskStatus = WhiskGenerationStatus.Failed;
            item.WhiskError = ex.Message;
        }
    }

    private string? GetBrollPromptsFilePath()
    {
        if (_resultSession == null) return null;

        if (!string.IsNullOrEmpty(_resultSession.OutputDirectory))
        {
            var directPath = Path.Combine(_resultSession.OutputDirectory, "broll-prompts.json");
            if (File.Exists(directPath)) return directPath;
        }

        if (!string.IsNullOrEmpty(_resultSession.OutputDirectory))
        {
            var relativePath = Path.Combine(Directory.GetCurrentDirectory(), _resultSession.OutputDirectory, "broll-prompts.json");
            if (File.Exists(relativePath)) return relativePath;
        }
        
        var constructedPath = Path.Combine(Directory.GetCurrentDirectory(), "output", _resultSession.Id, "broll-prompts.json");
        if (File.Exists(constructedPath)) return constructedPath;

        return constructedPath;
    }

    private void InvalidateBrollClassification()
    {
        // Delete all associated media files before clearing the list
        foreach (var item in _brollPromptItems)
        {
            // Delete Whisk image
            if (!string.IsNullOrEmpty(item.WhiskImagePath) && File.Exists(item.WhiskImagePath))
            {
                try { File.Delete(item.WhiskImagePath); } catch { }
            }
            
            // Delete Whisk video (Ken Burns)
            if (!string.IsNullOrEmpty(item.WhiskVideoPath) && File.Exists(item.WhiskVideoPath))
            {
                try { File.Delete(item.WhiskVideoPath); } catch { }
            }
            
            // Delete filtered video
            if (!string.IsNullOrEmpty(item.FilteredVideoPath) && File.Exists(item.FilteredVideoPath))
            {
                try { File.Delete(item.FilteredVideoPath); } catch { }
            }
            
            // Delete downloaded b-roll videos
            foreach (var video in item.SearchResults)
            {
                if (!string.IsNullOrEmpty(video.LocalPath) && File.Exists(video.LocalPath))
                {
                    try { File.Delete(video.LocalPath); } catch { }
                }
            }
        }

        _brollPromptItems.Clear();
        _classifyTotalSegments = 0;
        _classifyCompletedSegments = 0;

        var filePath = GetBrollPromptsFilePath();
        if (filePath != null && File.Exists(filePath))
        {
            try { File.Delete(filePath); }
            catch { }
        }
    }

    private async Task SaveBrollPromptsToDisk()
    {
        var filePath = GetBrollPromptsFilePath();
        if (filePath == null || _brollPromptItems.Count == 0) return;

        try
        {
            var saveData = _brollPromptItems.Select(i => new BrollPromptSaveItem
            {
                Index = i.Index, Timestamp = i.Timestamp, ScriptText = i.ScriptText,
                MediaType = i.MediaType, Prompt = i.Prompt, Reasoning = i.Reasoning,
                WhiskStatus = i.WhiskStatus, WhiskImagePath = i.WhiskImagePath, WhiskError = i.WhiskError,
                SelectedVideoUrl = i.SelectedVideoUrl, KenBurnsMotion = i.KenBurnsMotion,
                WhiskVideoStatus = i.WhiskVideoStatus, WhiskVideoPath = i.WhiskVideoPath, WhiskVideoError = i.WhiskVideoError,
                Style = i.Style, Filter = i.Filter, Texture = i.Texture, FilteredVideoPath = i.FilteredVideoPath
            }).ToList();

            var json = System.Text.Json.JsonSerializer.Serialize(saveData, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = true,
                Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() }
            });
            await File.WriteAllTextAsync(filePath, json);
        }
        catch (Exception ex)
        {
            _saveError = $"Gagal menyimpan broll prompts: {ex.Message}";
            Console.Error.WriteLine($"Failed to save broll prompts: {ex.Message}");
        }
    }

    private async Task SaveImageConfigToDisk()
    {
        var brollPath = GetBrollPromptsFilePath();
        if (brollPath == null) return;

        var configPath = Path.Combine(Path.GetDirectoryName(brollPath)!, "image-config.json");
        try
        {
            var json = System.Text.Json.JsonSerializer.Serialize(_imagePromptConfig, new System.Text.Json.JsonSerializerOptions
            {
                WriteIndented = true,
                Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() }
            });
            await File.WriteAllTextAsync(configPath, json);
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Failed to save image config: {ex.Message}");
        }
    }

    private async Task LoadImageConfigFromDisk()
    {
        var brollPath = GetBrollPromptsFilePath();
        if (brollPath == null) return;

        var configPath = Path.Combine(Path.GetDirectoryName(brollPath)!, "image-config.json");
        if (!File.Exists(configPath)) return;

        try
        {
            var json = await File.ReadAllTextAsync(configPath);
            var loaded = System.Text.Json.JsonSerializer.Deserialize<ImagePromptConfig>(json, new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() }
            });
            if (loaded != null)
            {
                _imagePromptConfig = loaded;
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Failed to load image config: {ex.Message}");
        }
    }

    private async Task LoadBrollPromptsFromDisk()
    {
        var filePath = GetBrollPromptsFilePath();
        if (filePath == null || !File.Exists(filePath)) return;

        try
        {
            var json = await File.ReadAllTextAsync(filePath);
            var saveItems = System.Text.Json.JsonSerializer.Deserialize<List<BrollPromptSaveItem>>(json, new System.Text.Json.JsonSerializerOptions
            {
                PropertyNameCaseInsensitive = true,
                Converters = { new System.Text.Json.Serialization.JsonStringEnumConverter() }
            });

            if (saveItems != null)
            {
                _brollPromptItems = saveItems.Select(s => new BrollPromptItem
                {
                    Index = s.Index, Timestamp = s.Timestamp, ScriptText = s.ScriptText,
                    MediaType = s.MediaType, Prompt = s.Prompt, Reasoning = s.Reasoning,
                    WhiskStatus = s.WhiskStatus, WhiskImagePath = s.WhiskImagePath, WhiskError = s.WhiskError,
                    SelectedVideoUrl = s.SelectedVideoUrl,
                    KenBurnsMotion = (s.MediaType == BrollMediaType.ImageGeneration && s.KenBurnsMotion == KenBurnsMotionType.None)
                        ? BrollPromptItem.GetRandomMotion() : s.KenBurnsMotion,
                    WhiskVideoStatus = s.WhiskVideoStatus, WhiskVideoPath = s.WhiskVideoPath, WhiskVideoError = s.WhiskVideoError,
                    Style = s.Style, Filter = s.Filter, Texture = s.Texture, FilteredVideoPath = s.FilteredVideoPath
                }).ToList();

                // Sanitize paths on load
                bool changed = false;
                foreach (var item in _brollPromptItems)
                {
                    if (!string.IsNullOrEmpty(item.WhiskImagePath) && item.WhiskImagePath.Contains("output\\scripts\\"))
                    {
                        // Fix absolute paths that incorrectly include 'scripts'
                        item.WhiskImagePath = item.WhiskImagePath.Replace("output\\scripts\\", "output\\");
                        changed = true;
                    }
                }
                if (changed) await SaveBrollPromptsToDisk();
            }
        }
        catch (Exception ex)
        {
            Console.Error.WriteLine($"Failed to load broll prompts: {ex.Message}");
        }
    }

    private async Task HandleApplyFilterToVideo(BrollPromptItem item)
    {
        if (item.IsFilteringVideo) return;
        
        try
        {
            item.IsFilteringVideo = true;
            item.FilterError = null;
            item.FilterProgress = 0;
            item.FilterStatus = "Initializing...";
            StateHasChanged();

            string? localPath = null;
            VideoAsset? selectedVideo = null;

            if (item.MediaType == BrollMediaType.ImageGeneration)
            {
                if (!string.IsNullOrEmpty(item.WhiskVideoPath) && File.Exists(item.WhiskVideoPath))
                {
                    localPath = item.WhiskVideoPath;
                }
                else
                {
                    throw new InvalidOperationException("No generated video available to filter. Convert image to video first.");
                }
            }
            else // BrollMediaType.BrollVideo
            {
                if (item.SearchResults.Count > 0)
                {
                    selectedVideo = item.SearchResults.FirstOrDefault(v => v.DownloadUrl == item.SelectedVideoUrl)
                                        ?? item.SearchResults.First();
                    
                    if (!string.IsNullOrEmpty(selectedVideo.LocalPath) && File.Exists(selectedVideo.LocalPath))
                    {
                        localPath = selectedVideo.LocalPath;
                    }
                }
                else
                {
                    throw new InvalidOperationException("No video selected to filter.");
                }

                if (string.IsNullOrEmpty(localPath) || !File.Exists(localPath))
                {
                    item.FilterProgress = 10;
                    item.FilterStatus = "Downloading source...";
                    StateHasChanged();

                    // Download video to session's output directory
                    var videosDir = !string.IsNullOrEmpty(_resultSession?.OutputDirectory)
                        ? Path.Combine(_resultSession.OutputDirectory, "videos")
                        : Path.Combine(Directory.GetCurrentDirectory(), "output", _sessionId ?? "temp", "videos");
                        
                    localPath = await DownloaderService.DownloadVideoToDirectoryAsync(
                        selectedVideo, videosDir, item.Index, "preview-source", CancellationToken.None);
                    
                    selectedVideo.LocalPath = localPath;
                }

                if (string.IsNullOrEmpty(localPath) || !File.Exists(localPath))
                {
                    throw new Exception("Could not download source video.");
                }
            }

            item.FilterProgress = 40;
            item.FilterStatus = $"Applying {item.EffectiveFilter} + {item.EffectiveTexture}...";
            StateHasChanged();

            var videoConfig = new ShortVideoConfig { Ratio = AspectRatio.Landscape_16x9 };

            var filteredPath = await VideoComposer.ApplyFilterAndTextureToVideoAsync(
                localPath, item.EffectiveFilter, item.FilterIntensity, item.EffectiveTexture, item.TextureOpacity, videoConfig, CancellationToken.None, isPreview: true);

            if (!string.IsNullOrEmpty(filteredPath))
            {
                // Save filtered video to session's output directory
                var outputDir = !string.IsNullOrEmpty(_resultSession?.OutputDirectory)
                    ? Path.Combine(_resultSession.OutputDirectory, "filtered")
                    : Path.Combine(Directory.GetCurrentDirectory(), "output", _sessionId ?? "temp", "filtered");
                Directory.CreateDirectory(outputDir);
                var finalFileName = $"filtered_{item.Index:D2}_{Guid.NewGuid().ToString("N")[..8]}.mp4";
                var finalPath = Path.Combine(outputDir, finalFileName);
                
                File.Move(filteredPath, finalPath, overwrite: true);
                item.FilteredVideoPath = finalPath;
                
                item.FilterProgress = 100;
                item.FilterStatus = "Done!";
                StateHasChanged();
                await Task.Delay(500);
            }
            else
            {
                throw new Exception("Filter application returned null path.");
            }

            await SaveBrollPromptsToDisk();
        }
        catch (Exception ex)
        {
            item.FilterError = $"Filter failed: {ex.Message}";
            Console.Error.WriteLine($"Filter error: {ex}");
        }
        finally
        {
            item.IsFilteringVideo = false;
            StateHasChanged();
        }
    }

    private async Task HandleExportLrc()
    {
        if (_isExportingLrc || _resultSession == null) return;
        _isExportingLrc = true;
        _errorMessage = null;
        _lrcExportPath = null;
        StateHasChanged();

        try
        {
            var lrcContent = GenerateLrcContent();
            var safeTopic = System.Text.RegularExpressions.Regex.Replace(_resultSession.Topic ?? "script", @"[^a-zA-Z0-9\-]", "_");
            var safeFilename = $"{safeTopic}_{DateTime.Now:yyyyMMddHHmm}";
            var lrcPath = System.IO.Path.Combine(Environment.CurrentDirectory, "wwwroot", "exports", $"{safeFilename}.lrc");
            
            System.IO.Directory.CreateDirectory(System.IO.Path.GetDirectoryName(lrcPath)!);
            await File.WriteAllTextAsync(lrcPath, lrcContent, System.Text.Encoding.UTF8);

            // Trigger download
            var bytes = System.Text.Encoding.UTF8.GetBytes(lrcContent);
            var base64 = Convert.ToBase64String(bytes);
            await JS.InvokeVoidAsync("downloadFile", $"{safeFilename}.lrc", base64, "text/plain");

            _lrcExportPath = lrcPath;
        }
        catch (Exception ex)
        {
            _errorMessage = $"Export LRC gagal: {ex.Message}";
        }
        finally
        {
            _isExportingLrc = false;
            StateHasChanged();
        }
    }

    private void HandleImportSrt(Microsoft.AspNetCore.Components.Forms.InputFileChangeEventArgs e)
    {
        var file = e.File;
        RequestConfirmation(
            "Import SRT", 
            "‚ö†Ô∏è DESTRUCTIVE: Ini akan menimpa SEMUA script phase yang ada dengan isi file SRT. \n\n" +
            "Semua B-Roll prompt dan image generation steps yang sudah ada akan DIHAPUS/DIRESET. \n\n" +
            "Apakah Anda yakin ingin melanjutkan?", 
            async () => await ProcessImportSrt(file));
    }

    private async Task ProcessImportSrt(Microsoft.AspNetCore.Components.Forms.IBrowserFile file)
    {
        if (_resultSession == null) return;
        _isImportingSrt = true;
        
        // DESTRUCTIVE: Delete all old assets and prompts first
        InvalidateBrollClassification();
        
        StateHasChanged();
        await Task.Delay(50); // Yield UI

        try 
        {
            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB limit
            using var reader = new System.IO.StreamReader(stream, System.Text.Encoding.UTF8);
            var srtContent = await reader.ReadToEndAsync();

            var segments = ParseSrtToSegments(srtContent);
            
            if (segments.Count == 0)
            {
                _errorMessage = "Gagal memproses file SRT: Tidak ada segment yang valid.";
                _isImportingSrt = false;
                StateHasChanged();
                return;
            }

            // Create fresh items
            _brollPromptItems = segments.Select((seg, i) => new BrollPromptItem
            {
                Index = i + 1,
                Timestamp = seg.Timestamp,
                // Always use chunk text (seg.Text) for display - each micro-beat shows its unique portion
                // OriginalText was causing all micro-beats from the same SRT segment to show the same full paragraph
                ScriptText = seg.Text,
                MediaType = BrollMediaType.BrollVideo
            }).ToList();

            await SaveBrollPromptsToDisk();

            // Switch to broll-prompts view ‚Äî user can now configure prompt settings before running classification
            _currentView = "broll-prompts";
            _isImportingSrt = false;
            StateHasChanged();
        }
        catch (Exception ex)
        {
            _errorMessage = $"Gagal import SRT: {ex.Message}";
            _isImportingSrt = false;
            StateHasChanged();
        }
    }

    private List<MicroBeatSegment> ParseSrtToSegments(string srtContent)
    {
        // Use phase-aware splitting for visual hooking in first 3 minutes
        var microBeats = SrtService.ParseWithPhaseSplitting(srtContent, PhaseDetectionService, TimestampSplitterService);

        // Return full MicroBeatSegment objects to preserve PhaseId, OriginalText, etc.
        return microBeats;
    }

    /// <summary>
    /// Parse timestamp string [MM:SS.mmm] into TimeSpan
    /// Used for phase detection during SRT import
    /// </summary>
    private bool TryParseTimestamp(string timestamp, out TimeSpan result)
    {
        result = TimeSpan.Zero;

        if (string.IsNullOrWhiteSpace(timestamp))
            return false;

        // Remove brackets and parse
        var clean = timestamp.Trim().Trim('[', ']');

        // Format: [MM:SS.mmm] or [HH:MM:SS.mmm]
        var parts = clean.Split(':');
        if (parts.Length == 2)
        {
            // MM:SS.mmm format
            if (int.TryParse(parts[0], out var minutes) &&
                double.TryParse(parts[1], System.Globalization.NumberStyles.Float,
                    System.Globalization.CultureInfo.InvariantCulture, out var seconds))
            {
                result = TimeSpan.FromMinutes(minutes) + TimeSpan.FromSeconds(seconds);
                return true;
            }
        }
        else if (parts.Length == 3)
        {
            // HH:MM:SS.mmm format
            if (int.TryParse(parts[0], out var hours) &&
                int.TryParse(parts[1], out var minutes) &&
                double.TryParse(parts[2], System.Globalization.NumberStyles.Float,
                    System.Globalization.CultureInfo.InvariantCulture, out var seconds))
            {
                result = TimeSpan.FromHours(hours) + TimeSpan.FromMinutes(minutes) + TimeSpan.FromSeconds(seconds);
                return true;
            }
        }

        return false;
    }

  
    private string GenerateLrcContent()
    {
        var sb = new System.Text.StringBuilder();
        var globalOffset = TimeSpan.Zero;
        // Regex to parse [mm:ss] or [mm:ss.f] or [mm:ss.ff] or [mm:ss.fff]
        // \d{1,3} : minutes (can be > 99)
        // \d{2}   : seconds
        // (?:.(\d{1,3}))? : optional milliseconds part
        var timestampPattern = new System.Text.RegularExpressions.Regex(@"\[(\d{1,3}):(\d{2})(?:\.(\d{1,3}))?\]", System.Text.RegularExpressions.RegexOptions.Compiled);

        foreach (var section in _resultSections.OrderBy(s => s.Order))
        {
            if (string.IsNullOrWhiteSpace(section.Content)) continue;
            var entries = ParseTimestampedEntries(section.Content, timestampPattern);

            if (entries.Count == 0)
            {
                var cleaned = CleanSubtitleText(section.Content);
                if (!string.IsNullOrWhiteSpace(cleaned))
                {
                    var durationSec = EstimateDuration(cleaned);
                    var duration = TimeSpan.FromSeconds(durationSec);
                    
                    var lines = SplitAndTimestampText(cleaned, globalOffset, duration);
                    foreach(var line in lines) sb.AppendLine(line);

                    globalOffset = globalOffset.Add(duration);
                }
                continue;
            }

            var phaseBase = entries[0].Timestamp;
            
            for (int i = 0; i < entries.Count; i++)
            {
                var entry = entries[i];
                var normalizedTime = entry.Timestamp - phaseBase;
                if (normalizedTime < TimeSpan.Zero) normalizedTime = TimeSpan.Zero;
                var absoluteTime = globalOffset.Add(normalizedTime);
                
                var cleaned = CleanSubtitleText(entry.Text);
                if (string.IsNullOrWhiteSpace(cleaned)) continue;

                TimeSpan entryDuration;
                if (i < entries.Count - 1)
                {
                     var nextNormalized = entries[i + 1].Timestamp - phaseBase;
                     if (nextNormalized < TimeSpan.Zero) nextNormalized = TimeSpan.Zero;
                     entryDuration = nextNormalized - normalizedTime;
                }
                else
                {
                     entryDuration = TimeSpan.FromSeconds(EstimateDuration(entry.Text));
                }

                // If duration is too short (e.g. same timestamp), fallback to estimate
                if (entryDuration.TotalSeconds < 1)
                     entryDuration = TimeSpan.FromSeconds(EstimateDuration(entry.Text));

                var lines = SplitAndTimestampText(cleaned, absoluteTime, entryDuration);
                foreach(var line in lines) sb.AppendLine(line);
            }

            // Update globalOffset for next phase
            if (entries.Count > 0)
            {
                var lastEntry = entries.Last();
                var lastNormTime = lastEntry.Timestamp - phaseBase;
                if (lastNormTime < TimeSpan.Zero) lastNormTime = TimeSpan.Zero;
                var lastEntryDuration = TimeSpan.FromSeconds(EstimateDuration(lastEntry.Text));
                globalOffset = globalOffset.Add(lastNormTime).Add(lastEntryDuration);
            }
        }

        return sb.ToString();
    }

    private List<string> SplitAndTimestampText(string text, TimeSpan startTime, TimeSpan duration)
    {
        const int MaxChars = 450; // Safer limit well below 490
        var result = new List<string>();
        
        var singleLine = System.Text.RegularExpressions.Regex.Replace(
                    text.Replace("\r\n", " ").Replace("\n", " ").Replace("\r", " "), @"\s+", " ").Trim();

        if (string.IsNullOrWhiteSpace(singleLine)) return result;

        if (singleLine.Length <= MaxChars)
        {
             result.Add(FormatLrcLine(startTime, singleLine));
             return result;
        }

        var words = singleLine.Split(' ');
        var chunks = new List<string>();
        var currentChunk = new System.Text.StringBuilder();

        foreach (var word in words)
        {
            // If a single word is excessively long, split it forcefully
            if (word.Length > MaxChars)
            {
                if (currentChunk.Length > 0)
                {
                    chunks.Add(currentChunk.ToString().Trim());
                    currentChunk.Clear();
                }

                var remainingWord = word;
                while (remainingWord.Length > MaxChars)
                {
                    chunks.Add(remainingWord.Substring(0, MaxChars));
                    remainingWord = remainingWord.Substring(MaxChars);
                }
                currentChunk.Append(remainingWord).Append(" ");
                continue;
            }

            if (currentChunk.Length + word.Length + 1 > MaxChars)
            {
                chunks.Add(currentChunk.ToString().Trim());
                currentChunk.Clear();
            }
            currentChunk.Append(word).Append(" ");
        }
        if (currentChunk.Length > 0) chunks.Add(currentChunk.ToString().Trim());

        // Distribute duration based on char count fraction
        double totalChars = singleLine.Length;
        var currentTime = startTime;
        
        foreach (var chunk in chunks)
        {
            result.Add(FormatLrcLine(currentTime, chunk));
            
            // Interpolate next start time
            // Duration of this chunk = TotalDuration * (ChunkLen / TotalLen)
            if (totalChars > 0)
            {
                var chunkDurationMs = duration.TotalMilliseconds * ((double)chunk.Length / totalChars);
                currentTime = currentTime.Add(TimeSpan.FromMilliseconds(chunkDurationMs));
            }
        }

        return result;
    }

    private string FormatLrcLine(TimeSpan ts, string text)
    {
        var minutes = (int)ts.TotalMinutes;
        var seconds = ts.Seconds;
        var centiseconds = ts.Milliseconds / 10;
        // Standard LRC format is [mm:ss.xx] (centiseconds)
        return $"[{minutes:D2}:{seconds:D2}.{centiseconds:D2}]{text}";
    }

    // Helper to parse content with timestamps
    private List<TimestampedEntry> ParseTimestampedEntries(string content, System.Text.RegularExpressions.Regex pattern)
    {
        var result = new List<TimestampedEntry>();
        var matches = pattern.Matches(content);
        
        for (int i = 0; i < matches.Count; i++)
        {
            var match = matches[i];
            if (!int.TryParse(match.Groups[1].Value, out var m)) continue;
            if (!int.TryParse(match.Groups[2].Value, out var s)) continue;
            
            var ms = 0;
            if (match.Groups[3].Success)
            {
                var val = match.Groups[3].Value;
                // Normalize "1" -> 100ms, "10" -> 100ms (if it was .10), need to be careful.
                // Actually usually .1 = 100ms, .01 = 10ms.
                // But .123 = 123ms. 
                // Let's assume standard decimal fraction parsing
                if (val.Length == 1) val += "00";
                else if (val.Length == 2) val += "0";
                
                if (int.TryParse(val, out var parsedMs)) ms = parsedMs;
            }

            var ts = new TimeSpan(0, 0, m, s, ms);
            var startIndex = match.Index + match.Length;
            var length = (i < matches.Count - 1) ? matches[i + 1].Index - startIndex : content.Length - startIndex;
            
            if (length <= 0) continue;
            
            var text = content.Substring(startIndex, length).Trim();
            result.Add(new TimestampedEntry(ts, text));
        }

        return result;
    }

    public record TimestampedEntry(TimeSpan Timestamp, string Text);

    private static bool IsOnlyHeader(string text)
    {
        var trimmed = text.Trim();
        return trimmed.StartsWith('#') ||
               System.Text.RegularExpressions.Regex.IsMatch(trimmed,
                   @"^\s*(?:Opening Hook|Kontekstualisasi|Multi-Dimensi|Climax|Eschatology|Contextualization|Content|Refleksi)\s*$",
                   System.Text.RegularExpressions.RegexOptions.IgnoreCase);
    }

    private string GetAssetUrl(string absolutePath)
    {
        if (string.IsNullOrEmpty(absolutePath)) return "";
        if (absolutePath.StartsWith("http", StringComparison.OrdinalIgnoreCase)) return absolutePath;

        // Resilient resolution
        var resolved = ResolveLocalPath(absolutePath);
        if (string.IsNullOrEmpty(resolved)) return "";

        var baseDir = Path.Combine(Directory.GetCurrentDirectory(), "output");
        try
        {
            var relative = Path.GetRelativePath(baseDir, resolved).Replace("\\", "/");
            return $"/project-assets/{relative}";
        }
        catch
        {
            // Fallback to basic string parsing if GetRelativePath fails
            var normalized = resolved.Replace("\\", "/");
            var markerIndex = normalized.IndexOf("output/", StringComparison.OrdinalIgnoreCase);
            if (markerIndex >= 0)
            {
                return $"/project-assets/{normalized.Substring(markerIndex + "output/".Length)}";
            }
            return absolutePath;
        }
    }

    private string ResolveLocalPath(string? absolutePath)
    {
        if (string.IsNullOrEmpty(absolutePath)) return "";
        
        // 1. Normalize and identify relative part after 'output/'
        var normalized = absolutePath.Replace("\\", "/");
        var baseDir = Path.Combine(Directory.GetCurrentDirectory(), "output");
        
        string relative = "";
        var markerIndex = normalized.IndexOf("output/", StringComparison.OrdinalIgnoreCase);
        if (markerIndex >= 0)
        {
            relative = normalized.Substring(markerIndex + "output/".Length);
        }
        else
        {
            // If it's already a relative path or something else, try to make it relative to output
            try { relative = Path.GetRelativePath(baseDir, absolutePath); } catch { relative = absolutePath; }
        }

        // 2. SMART RECOVERY: Strip incorrect 'scripts/' prefix if it's there (often accidental double nesting)
        if (relative.StartsWith("scripts/", StringComparison.OrdinalIgnoreCase))
        {
            var parts = relative.Split('/');
            if (parts.Length > 2 && parts[1].Length == 8) // Looks like scripts/<sessionId>/...
            {
                relative = string.Join("/", parts.Skip(1)); // Remove 'scripts/'
            }
        }

        // 3. Return the resolved path directly
        return Path.Combine(baseDir, relative.Replace("/", Path.DirectorySeparatorChar.ToString()));
    }

    private static int EstimateDuration(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return 1;
        var words = text.Split(new[] { ' ', '\t', '\n', '\r' }, StringSplitOptions.RemoveEmptyEntries);
        var baseDuration = words.Length / 2.33;
        var ellipsisCount = System.Text.RegularExpressions.Regex.Matches(text, @"\.\.\.").Count;
        var totalDuration = baseDuration + (ellipsisCount * 0.5);
        return (int)Math.Ceiling(Math.Max(3, totalDuration));
    }

    private static string CleanSubtitleText(string text)
    {
        if (string.IsNullOrWhiteSpace(text)) return string.Empty;
        var result = text;

        result = System.Text.RegularExpressions.Regex.Replace(result, @"^#+\s+.*$", "", System.Text.RegularExpressions.RegexOptions.Multiline);
        result = System.Text.RegularExpressions.Regex.Replace(result, @"^\s*(?:Opening Hook|Kontekstualisasi|Multi-Dimensi|Climax|Eschatology|Contextualization|Content|Segment \d+):?\s*$", "", System.Text.RegularExpressions.RegexOptions.Multiline | System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        result = System.Text.RegularExpressions.Regex.Replace(result, @"\[\d{1,3}:\d{2}(?::\d{2})?\]", "");
        result = System.Text.RegularExpressions.Regex.Replace(result, @"\b\d{1,3}:\d{2}(?::\d{2})?\b", "");
        result = System.Text.RegularExpressions.Regex.Replace(result, @"\[(?:Visual|Musik|Music|Efek|Effect|SFX|Audio|PAUSE)[^\]]*\]", "", System.Text.RegularExpressions.RegexOptions.IgnoreCase);
        result = System.Text.RegularExpressions.Regex.Replace(result, @"\([^)]*\)", "");
        result = result.Replace("\"", "").Replace("'", "");
        result = result.Replace("*", "").Replace("_", "");
        result = System.Text.RegularExpressions.Regex.Replace(result, @"#\S+", "");
        result = result.Replace("[", "").Replace("]", "");
        result = result.Replace(".. .", "").Replace("...", "");
        result = result.Replace("‚Äî", " ").Replace("‚Äì", " ").Replace("-", " ");
        result = System.Text.RegularExpressions.Regex.Replace(result, @"\s+", " ");
        result = result.Replace("Wallahuam bissawab", "Wallahu a'lam bish-shawab");
        result = result.Replace("Wallahualam bissawab", "Wallahu a'lam bish-shawab");
        
        return result.Trim();
    }

    private void RequestConfirmation(string title, string message, Func<Task> action)
    {
        _confirmTitle = title;
        _confirmMessage = message;
        _pendingConfirmAction = action;
        _showConfirmDialog = true;
        StateHasChanged();
    }

    private void CancelConfirm()
    {
        _showConfirmDialog = false;
        _pendingConfirmAction = null;
    }

    private async Task ExecuteConfirm()
    {
        _showConfirmDialog = false;
        if (_pendingConfirmAction != null)
        {
            await _pendingConfirmAction();
        }
        _pendingConfirmAction = null;
        StateHasChanged();
    }

    private class PhaseStatusItem
    {
        public string PhaseId { get; set; } = "";
        public string Name { get; set; } = "";
        public int Order { get; set; }
        public string Status { get; set; } = "Pending";
        public int WordCount { get; set; }
        public List<string>? OutlinePoints { get; set; }
        public string DurationTarget { get; set; } = "";
    }

    private class BrollPromptSaveItem
    {
        public int Index { get; set; }
        public string Timestamp { get; set; } = "";
        public string ScriptText { get; set; } = "";
        public BrollMediaType MediaType { get; set; }
        public string Prompt { get; set; } = "";
        public string Reasoning { get; set; } = "";
        public WhiskGenerationStatus WhiskStatus { get; set; }
        public string? WhiskImagePath { get; set; }
        public string? WhiskError { get; set; }
        public string? SelectedVideoUrl { get; set; }
        public KenBurnsMotionType KenBurnsMotion { get; set; }
        public WhiskGenerationStatus WhiskVideoStatus { get; set; }
        public string? WhiskVideoPath { get; set; }
        public string? WhiskVideoError { get; set; }
        public VideoStyle Style { get; set; }
        public VideoFilter Filter { get; set; }
        public VideoTexture Texture { get; set; }
        public string? FilteredVideoPath { get; set; }
    }
}
